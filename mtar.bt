LittleEndian();

/* Color defines. */
#define COLOR_HEADER 0x85CFCA
#define COLOR_LIST 0x8CBA80
#define COLOR_SECTION_1 0x9C8E65
#define COLOR_STRCODE32 0x634651

#include "common/common.bt"

#define FILE_TYPE_MTAR
#include "common/anim_common.bt"
		
#include "gani.bt"

struct MtarHeader
{
	uint Version;

	uint FileCount;
	
	ushort UnitCount; // Same as FRIG's RigUnit count

	ushort SegmentCount; // Same as FRIG's count

	ushort ShaderNodeCount; // Shows up in "_facial" - seems to be the number of SHADER nodes per animation

	ushort ShaderUnitCount; // Shows up in "_facial" - normally (always?) as 0x1

	ushort MotionPointUnitCount;

	enum <ushort> MTAR_FLAGS
	{
		MTAR_FLAGS_NEW = 0x1000,

		MTAR_FLAGS_HAS_SKEL_LIST = 0x4000,
	} Flags; Assert((Flags & ~(MTAR_FLAGS_NEW | MTAR_FLAGS_HAS_SKEL_LIST)) == 0);

	uint CommonInfoOffset;

	uint64 Padding <hidden = true>; Assert(Padding == 0);
} Header <bgcolor = COLOR_HEADER>;

if (Header.Flags & MTAR_FLAGS_NEW)
{
	struct MtarTableList2
	{
		PathCode64 Path; //Assert(((Path.hash >> 52) == (0xFC50 >> 4)) || ((Path.hash >> 52) == (0x4CB0 >> 4))); // Just confirming that these files are all GANIs by checking the extension
		uint TracksOffset;
		ushort TracksDataSize <read = (this << 4)>;

		ushort MotionPointTracksOffset <read = (this << 4)>;
		ushort MotionPointTracksDataSize <read = (this << 4)>;
		ushort ShaderTracksOffset <read = (this << 4)>; Assert(ShaderTracksOffset == 0);
		ushort ShaderTracksDataSize <read = (this << 4)>; Assert(ShaderTracksDataSize == 0); // This one is a guess as a way to justify why there's padding after. The exe does not use this value.

		ushort Padding0 <hidden = true>; Assert(Padding0 == 0);

		uint MotionEventsOffset;

		uint Padding1 <hidden = true>; Assert(Padding1 == 0);
	} List[Header.FileCount] <bgcolor = COLOR_LIST, optimize = true>;
}
else
{
	struct MtarTableList
	{
		PathCode64 Path; //Assert(((Path.hash >> 52) == (0xFC50 >> 4)) || ((Path.hash >> 52) == (0x4CB0 >> 4))); // Just confirming that these files are all GANIs by checking the extension
		uint TracksOffset;
		ushort TracksDataSize <read = (this << 4)>;
		ushort Unknown; // 7 in player2_facial_snake_helispace.mtar, sometimes 1 in TppPlayer2Facial
	} List[Header.FileCount] <bgcolor = COLOR_LIST, optimize = true>;
}

if (Header.CommonInfoOffset != 0)
{
    FSeek(Header.CommonInfoOffset);
    
	struct
	{
		typedef struct
		{
			StrCode32 Name;
		
			uint DataSize;
		
			uint NextNodeOffset;
		
			uint Padding <hidden = true>; Assert(Padding == 0);
		} MtarMiniDataNode <read = (Name.hash), bgcolor = COLOR_HEADER>;
		
		local int64 nodePos = FTell();
		local uint mnIdx = 0;
		do
		{
			FSeek(nodePos);

			MtarMiniDataNode Node;

			switch (Node.Name.hash)
			{
				case 1337830127:
					Assert(mnIdx == 0);
					disableTrackData = true;
					TrackHeader LayoutTrack;
					disableTrackData = false;
					break;
				case 2447659851:
					Assert((Header.Flags & MTAR_FLAGS_HAS_SKEL_LIST) != 0);
					StringData2 SkeletonList;
					break;
				case 999978884:
					Assert(mnIdx == 1);
					struct MotionPointList2
					{
						uint Count <hidden = true>;
						struct
						{
							StrCode32 Name;

							StrCode32 ParentName;
						} Entry[Count] <optimize = true>;
					} MotionPointList;
					break;
				default:
					Assert(false);
					break;
			}

			if (Node.NextNodeOffset == 0)
				break;

			nodePos = startof(Node) + Node.NextNodeOffset;
			mnIdx++;
		} while (nodePos != 0);
	} CommonInfo <bgcolor = COLOR_STRCODE32>;
}

if (Header.Flags & MTAR_FLAGS_NEW)
{
	local uint flIdx;
	for (flIdx = 0; flIdx < Header.FileCount; flIdx++)
	{
		FSeek(List[flIdx].TracksOffset);

		struct Gani2File
		{
			struct TrackMiniHeader
			{
				uint FrameCount;

				ubyte Padding0 <hidden = true>; Assert(Padding0 == 0);

				ubyte ParamCount;

				ushort Padding1 <hidden = true>; Assert(Padding1 == 0);

				local uint pIdx;
				for (pIdx = 0; pIdx < ParamCount; pIdx++)
				{
					struct Gani2Param
					{
						enum <uint> ParamName_StrCode32Alias
						{
							SLOPE_ANGLE = 35201703,
							SLOPE_DIR = 3426329078,
						} Name; Assert(Name == 35201703 || Name == 3426329078);
						float Value;
					} Param <read = Str("%s = %f", EnumToString(Name), Value)>;
				}

				TRACK_UNIT_FLAGS UnitFlags[Header.UnitCount];

				FAlign(4);

				struct Gani2TrackData
				{
					uint ComponentBitSize : 8;

					uint DataOffset : 24;
				} SegmentHeaders[CommonInfo.LayoutTrack.SegmentCount];

				FSkip(16);
				local uint tkIdx;
				local uint rlSgIdx;
				local uint sgIdx = 0;
				for (tkIdx = 0; tkIdx < Header.UnitCount; tkIdx++)
				{
					struct Gani2TrackUnit
					{
						for (rlSgIdx = 0; rlSgIdx < CommonInfo.LayoutTrack.Track[tkIdx].SegmentCount; rlSgIdx++, sgIdx++)
						{
							if (SegmentHeaders[sgIdx].DataOffset != 0)
							{
								FSeek(startof(SegmentHeaders[sgIdx]) + SegmentHeaders[sgIdx].DataOffset);

								TrackDataBlob Segment(CommonInfo.LayoutTrack.Track[tkIdx].Segments[rlSgIdx].Type, SegmentHeaders[sgIdx].ComponentBitSize, UnitFlags[tkIdx] & TRACK_UNIT_FLAGS_IS_STATIC);
							}
						}
					} Track;
				}
			} Tracks;

			FAlign(16);


			if (List[flIdx].MotionPointTracksOffset != 0)
			{
				FSeek(startof(this) + List[flIdx].MotionPointTracksOffset * 0x10);

				TrackHeader MotionPointTracks;
			}

			if (List[flIdx].MotionEventsOffset != 0)
			{
				FSeek(List[flIdx].MotionEventsOffset);

				EvpHeader MotionEvents;
			}
		} File <bgcolor = COLOR_SECTION_1>;
	}
}
else
{
	local uint flIdx;
	for (flIdx = 0; flIdx < Header.FileCount; flIdx++)
	{
		FSeek(List[flIdx].TracksOffset);

		struct GaniFile
		{
			FoxDataHeader Header<bgcolor = COLOR_HEADER>;

			FSeek(List[flIdx].TracksOffset + Header.NodesOffset);

			FoxDataNodes Nodes;
		} File <bgcolor = COLOR_SECTION_1>;
	}
}