#ifndef ANIM_COMMON_BT
#define ANIM_COMMON_BT

typedef struct
{
	ushort value <hidden = true>;
} AnimHalf <read = ReadAnimHalf>;
string ReadAnimHalf(AnimHalf& animHalf)
{
	local uint num1 = (animHalf.value & 0x7C00);
	if (num1 > 0)
		num1 = (num1 + 0x1dc00) << 13;      
	num1 |= ((animHalf.value & 0x8000) << 16) | ((animHalf.value & 0x3FF) << 13);

	local ubyte value[4];
	value[0] = (ubyte)((num1 >> 0) & 0xFF);
	value[1] = (ubyte)((num1 >> 8) & 0xFF);
	value[2] = (ubyte)((num1 >> 16) & 0xFF);
	value[3] = (ubyte)((num1 >> 24) & 0xFF);

	float result = ConvertBytesToFloat(value);

	return Str("%f", result);
}

enum <ubyte> SEGMENT_TYPE
{
	SEGMENT_TYPE_QUAT = 0,
	SEGMENT_TYPE_FLOAT = 1,
	SEGMENT_TYPE_VECTOR2 = 2,
	SEGMENT_TYPE_VECTOR3 = 3,
	SEGMENT_TYPE_VECTOR4 = 4,
	SEGMENT_TYPE_QUAT_DIFF = 5,
	SEGMENT_TYPE_VECTOR_DIFF = 6,
};

typedef struct
{
	AnimHalf x;
	AnimHalf y;
	AnimHalf z;
} VectorAnimH3 <read = Str("(%s, %s, %s)", ReadAnimHalf(x), ReadAnimHalf(y), ReadAnimHalf(z))>;

typedef struct
{
	AnimHalf x;
	AnimHalf y;
	AnimHalf z;
	AnimHalf w;
} VectorAnimH4 <read = Str("(%s, %s, %s, %s)", ReadAnimHalf(x), ReadAnimHalf(y), ReadAnimHalf(z), ReadAnimHalf(w))>;

// These are not padded! BitfieldDisablePadding() needs to be called before using them. 
// The frame count after each instance is also not padded!
typedef struct
{
	ushort Theta : 12;
	ushort Y : 12;
	ushort Z : 12;
	ushort X_Sign : 1;
	ushort Y_Sign : 1;
	ushort Z_Sign : 1;
} QuatAnim12;

typedef struct
{
	ushort Theta : 13;
	ushort Y : 13;
	ushort Z : 13;
	ushort X_Sign : 1;
	ushort Y_Sign : 1;
	ushort Z_Sign : 1;
} QuatAnim13;

typedef struct
{
	ushort Theta : 15;
	ushort Y : 15;
	ushort Z : 15;
	ushort X_Sign : 1;
	ushort Y_Sign : 1;
	ushort Z_Sign : 1;
} QuatAnim15;

struct SegmentKeyframeData(SEGMENT_TYPE type, ubyte componentBitSize)
{
	switch (type)
	{
	case SEGMENT_TYPE_QUAT:
		switch (componentBitSize)
		{
		case 12:
			QuatAnim12 Value;
			break;
		case 13:
			QuatAnim13 Value;
			break;
		case 15:
			QuatAnim15 Value;
			break;
		default:
			Assert(false);
			break;
		}
		break;
	case SEGMENT_TYPE_FLOAT:
		switch (componentBitSize)
		{
		case 16:
			AnimHalf Value;
			break;
		case 32:
			float Value;
			break;
		default:
			Assert(false);
			break;
		}
		break;
	case SEGMENT_TYPE_VECTOR3:
		switch (componentBitSize)
		{
		case 0:
			break;
		case 16:
			VectorAnimH3 Value;
			break;
		case 32:
			Vector3 Value;
			break;
		default:
			Assert(false);
			break;
		}
		break;
	case SEGMENT_TYPE_VECTOR4:
		switch (componentBitSize)
		{
		case 16:
			VectorAnimH4 Value;
			break;
		case 32:
			Vector4 Value;
			break;
		default:
			Assert(false);
			break;
		}
		break;
	case SEGMENT_TYPE_QUAT_DIFF:
		switch (componentBitSize)
		{
		case 12:
			QuatAnim12 Value;
			break;
		case 15:
			QuatAnim15 Value;
			break;
		default:
			Assert(false);
			break;
		}
		break;
	case SEGMENT_TYPE_VECTOR_DIFF:
		switch (componentBitSize)
		{
		case 32:
			Vector3 Value;
			break;
		case 16:
			VectorAnimH3 Value;
			break;
		default:
			Assert(false);
			break;
		}
		break;
	default:
		Printf("@%Lx Unknown component bit size: %u\n", FTell(), componentBitSize);
		Assert(false);
		break;
	}
};

struct TrackDataBlob(SEGMENT_TYPE type, ubyte componentBitSize, ubyte isStatic)
{
	if (!(componentBitSize == 16 || componentBitSize == 32))
		BitfieldDisablePadding();
	SegmentKeyframeData FirstKey(type, componentBitSize);
	if (!(componentBitSize == 16 || componentBitSize == 32))
		BitfieldEnablePadding();

	if (!(componentBitSize == 16 || componentBitSize == 32))
		BitfieldDisablePadding();
	if (isStatic == 0)
	{
		local uint frameIndex = 0;
		do
		{
			struct AnimKeyframe(SEGMENT_TYPE type, ubyte componentBitSize)
			{
				ubyte FrameCount : 8;

				SegmentKeyframeData Data(type, componentBitSize);
			} Key(type, componentBitSize);

			frameIndex += Key.FrameCount;
		}
		while (frameIndex < FrameCount);
	}
	if (!(componentBitSize == 16 || componentBitSize == 32))
		BitfieldEnablePadding();

	FAlign(2);
};

typedef enum <ubyte>
{
	TRACK_UNIT_FLAGS_LOOP = 0x1,
	TRACK_UNIT_FLAGS_HERMITE_VECTOR_INTERPOLATION = 0x2,
	TRACK_UNIT_FLAGS_IS_STATIC = 0x4,
} TRACK_UNIT_FLAGS <read = ReadTrackUnitFlags>;
string ReadTrackUnitFlags(TRACK_UNIT_FLAGS flags)
{
	local string result = flags == 0 ? "" : "| ";
	local ubyte i;
	local string enumName;
	local TRACK_UNIT_FLAGS temp;
	for (i = 1; i < 0x8; i = i << 1)
	{
		temp = flags & i;
		enumName = EnumToString(temp);
		if (enumName != "")
			result += " " + enumName + " |";
	}

	return result;
}

local int disableTrackData = false;

typedef struct
{
	int UnitCount;

	uint SegmentCount;
	
	ushort Id;

	byte UnknownA <hidden = true>; Assert(UnknownA == 0);
	byte UnknownB; Assert(UnknownB == 1);

	uint FrameCount;

	byte FrameRate; FSkip(3);

	if (UnitCount > 0)
	{
		uint UnitOffsets[UnitCount] <hidden = true>;

		local uint trkIdx;
		local uint sgmIdx;
		for (trkIdx = 0; trkIdx < UnitCount; trkIdx++)
		{
			FSeek(startof(this) + UnitOffsets[trkIdx]);

			struct TrackUnit
			{
				// For SAND, hash of the sub object, like a bone, ie SKL_000_WAIST. For GANI, it's the name of a Motion Point.
				enum <uint> TrackName_StrCode32Alias
				{
					// CANI, UIA, etc.
					ROTATE          = 283103795,
					SCALE           = 2236677358,
					TRANSLATE       = 2739596730,
					COLOR           = 1662570759,
					
					//IK
					RIG_ROOT        = 3552837520,

					// MTAR
					TensionController = 2275904709,
					TensionShift = 2003538961,
					TensionRate = 853304191,

					// 
				} Name;

				ubyte SegmentCount; sgmIdx = sgmIdx + SegmentCount;

				TRACK_UNIT_FLAGS Flags;

				ushort Padding <hidden = true>; Assert(Padding == 0);

				if (SegmentCount != 0)
				{
					struct TrackData
					{
						int DataOffset;

						short Id; // Segment id
						
						SEGMENT_TYPE Type : 4;

						ubyte NextEntryOffset : 4; Assert(NextEntryOffset == 0 || NextEntryOffset == 8); // The offset to the next entry is (NextEntryOffset & 0x8). since NextEntryOffset is always 0 or 8, this does nothing. 

						ubyte ComponentBitSize;
						
						if (DataOffset != 0 && !disableTrackData)
						{
							FSeek(startof(this) + DataOffset);

							TrackDataBlob Data(Type, ComponentBitSize, Flags & TRACK_UNIT_FLAGS_IS_STATIC);

							if (NextEntryOffset != 0)
								FSeek(startof(this) + NextEntryOffset);
						}
					} Segments[SegmentCount] <read = EnumToString(Type), optimize = false>;
				}
			} Track;
		}
	}
} TrackHeader <bgcolor = 0x8ADEF3>;

struct FoxDataName;
struct StringData
{
	uint EntryCount <hidden = true>;
	local int64 strIdx;
	for (strIdx = 0; strIdx < EntryCount; strIdx++)
	{
		FoxDataName Entry <optimize = true>;
	}
};

struct StringData2
{
	uint EntryCount <hidden = true>;
	local int64 strIdx;
	StrCode32 Entries[EntryCount] <optimize = true>;
};

enum <uint> NODE_TYPE
{
	NODE_TYPE_STRINGDATA = 0,
	NODE_TYPE_TRACKS = 1,
	NODE_TYPE_EVENTS = 3,
};

//Hack for PS3 files
typedef struct
{
	uint paramA <hidden=true>;
	uint paramB <hidden=true>;
	local StrCode param<format=hex>;
	param.hash = (uint64)paramA | ((uint64)paramB << 32);
} PARAM_STRING <read=Str("%I64u",param.hash)>; 

typedef struct
{
	enum <uint> EvfCategoryName_StrCode32Alias
	{
		Normal = 3371498678,
		ag = 2079928349,
		cc = 3342815349,
		fx = 2569337208,
		sd = 179473302,
		vo = 1455888052,
	} CategoryName;

	ushort UnitCount <hidden = true>;

	ushort CacheOffset;

	if (UnitCount != 0)
		uint UnitOffsets[UnitCount] <hidden = true>;

	local uint sIdx;
	for (sIdx = 0; sIdx < UnitCount; sIdx++)
	{
		FSeek(startof(this) + UnitOffsets[sIdx]);
		
		struct EventUnitInfo
		{
			enum <uint> EventUnitInfoName_StrCode32Alias
			{
				// fx
				FX_CREATE_EFFECT_WITH_SKL = 312449893,

				// ag
				MTEV_AG_SYNC_L = 877721620,
				MTEV_AG_SYNC_R = 3647133869,
				MTEV_FOOT_STOP_R = 2051014260,
				MTEV_FOOT_STOP_L = 4246579437,
				MTEV_FOOT_START_R = 3689287927,
				MTEV_FOOT_START_L = 3049626829,

				// sd
				right_foot_ground = 2122718581,
				right_foot_leave = 3453979597,
				left_foot_ground = 1190238672,
				left_foot_leave = 3446064903,
				rattle_weapon = 2416440354,
				rattle_suit = 1532442511,
				
				// Demo
				ExecCommand = 595181585,
				DemoStart = 3541589503,
				DemoEnd = 3534133658,
				CreateLocator = 2523762371,
				CreateModel = 3313525351,
				VisibleModel = 1040836537,
				VisibleMesh = 1799953944,
				DeleteLocator = 826863926,
				DeleteModel = 1968729831,
				CreateCamera = 2135789169,
				DeleteCamera = 4099945744,
				ClipEnd = 708232468,
			
				// 3487515216 - List of StringParams passed to MotionGraphControl::AddCurrentNodeTag (and seemingly removes them at the end with MotionGraphControl::RemoveCurrentNodeTag)
			} Name;
			
			//Printf(Str("%u\n",Name));

			byte TimeSectionCount : 6 <hidden = true>;
			enum <byte> TIME_SECTION_FORMAT
			{
				TIME_SECTION_FORMAT_INT = 0,
				TIME_SECTION_FORMAT_SHORT = 1,
				TIME_SECTION_FORMAT_BYTE = 2,
				TIME_SECTION_FORMAT_INFINITE = 3,
			} Format : 2 <hidden = true>;

			byte IntParamCount <hidden = true>;
			byte FloatParamCount <hidden = true>;
			byte StringParamCount <hidden = true>;

			if (TimeSectionCount != 0)
			{
				struct TimeSection
				{
					switch (parentof(this).Format)
					{
					case TIME_SECTION_FORMAT_INT:
						int StartFrame <read = (this < 0 ? this : this & 0xBFFFFFFF)>;
						int EndFrame <read = (this < 0 ? this : this & 0xBFFFFFFF)>;
						break;
					case TIME_SECTION_FORMAT_SHORT:
						short StartFrame;
						short EndFrame;
						break;
					case TIME_SECTION_FORMAT_BYTE:
						byte StartFrame;
						byte EndFrame;
						break;
					case TIME_SECTION_FORMAT_INFINITE:
						break;
					}
					// This read function gets messy because of the formats but basically it's just saying TIME_SECTION_FORMAT_INFINITE -> (-1, 1), else to whatever the read function above is (which is only non-default for TYPE_INT).
				} TimeSections[TimeSectionCount] <read = (parentof(this).Format == TIME_SECTION_FORMAT_INFINITE ? "(-1, -1)" : Str("(%d, %d)", parentof(this).Format == TIME_SECTION_FORMAT_INT ? (StartFrame < 0 ? StartFrame : StartFrame & 0xBFFFFFFF) : StartFrame, parentof(this).Format == TIME_SECTION_FORMAT_INT ? (EndFrame < 0 ? EndFrame : EndFrame & 0xBFFFFFFF) : EndFrame)), optimize = true>;
			}

			FAlign(4);

			if (IntParamCount != 0)
				uint IntParams[IntParamCount];

			if (FloatParamCount != 0)
				float FloatParams[FloatParamCount];

			if (StringParamCount != 0)
			{
				PARAM_STRING StringParams[StringParamCount] <optimize = false>;
				//event string hash dump
				/*
				local uint stringIdx;
				for (stringIdx = 0; stringIdx < StringParamCount; stringIdx++)
				{
					Printf(Str("%I64u\n",StringParams[stringIdx].param.hash));
				}
				*/
				//vfx name dump
				/*
				if (Name==595181585)
				{
					if (StringParamCount>7)
					{
						if (StringParams[6].param.hash==39224491583389
						||StringParams[6].param.hash==72256544285556
						||StringParams[6].param.hash==32886448170624
						||StringParams[7].param.hash==173102471356897
						||StringParams[6].param.hash==34251201099326)
						{
							Printf(Str("%I64u\n",StringParams[0].param.hash));
						};
					};
				}
				*/
				//human target hash dump
				/*if (Name==1968729831)
				{
					if (StringParamCount!=0)
					{
						Printf(Str("%I64u\n",StringParams[0].param.hash));
					}
				}*/
				//mesh group hash dump
				/*if (Name==1799953944)
				{
					Printf(Str("target: %I64u mesh group: %I64u\n",StringParams[0].param.hash,StringParams[1].param.hash));
				}*/
				//prp_ hash dump
				/*if (Name==2523762371)
				{
					Printf(Str("%I64u\n",StringParams[0].param.hash));
				}*/
				// if (Name==595181585)
				// {
				// 	if (StringParamCount>6)
				// 	{
				// 		if (StringParams[5].param.hash==84993817083062) 
				// 		{
				// 			local float divisor = 0.6*1000/1001;
				// 			Printf(Str("%f,%I64u\n",TimeSections[0].StartFrame/divisor,StringParams[1].param.hash));
				// 		}
				// 	}
				// }
				//event string hash dump
				/*
				local uint stringIdx;
				for (stringIdx = 0; stringIdx < StringParamCount; stringIdx++)
				{
					Printf(Str("%I64u\n",StringParams[stringIdx].param.hash));
				}
				*/
				//vfx name dump
				/*
				if (Name==595181585)
				{
					if (StringParamCount>7)
					{
						if (StringParams[6].param.hash==39224491583389
						||StringParams[6].param.hash==72256544285556
						||StringParams[6].param.hash==32886448170624
						||StringParams[7].param.hash==173102471356897
						||StringParams[6].param.hash==34251201099326)
						{
							Printf(Str("%I64u\n",StringParams[0].param.hash));
						};
					};
				}
				*/
				//human target hash dump
				/*if (Name==1968729831)
				{
					if (StringParamCount!=0)
					{
						Printf(Str("%I64u\n",StringParams[0].param.hash));
					}
				}*/
				//mesh group hash dump
				/*if (Name==1799953944)
				{
					Printf(Str("target: %I64u mesh group: %I64u\n",StringParams[0].param.hash,StringParams[1].param.hash));
				}*/
				//prp_ hash dump
				/*if (Name==2523762371)
				{
					Printf(Str("%I64u\n",StringParams[0].param.hash));
				}*/
				//.sani subtitles dump
				/*if (Name==595181585)
				{
					if (StringParamCount>6)
					{
						if (StringParams[5].param.hash==84993817083062) 
						{
							local float divisor = 0.60075*1000/1001;
							Printf(Str("subp: %f,%I64u\n",TimeSections[0].StartFrame/divisor,StringParams[1].param.hash));
						}
					}
				}*/
			}
		} Event <read = EnumToString(Name)>;
	}

	if (CacheOffset != 0)
	{
		FSeek(startof(this) + CacheOffset);

		struct EventCache
		{
			switch (parentof(this).CategoryName)
			{
			case ag:
				struct AnimGraphEventCache
				{
					struct MotionGraphFootFitEventCacheData // MotionGrpahFootFitEventCacheData
					{
						// Completely derived from MTEV_AG_SYNC_L and MTEV_AG_SYNC_R events. Frames list is from respective event time sections sorted in order by StartFrame.
						// If animation is loop, Info.StartFrame = -(first event in order).Section.StartFrame, else 0.
						struct MotionGraphFootFitInfo // MotionGrpahFootFitInfo
						{
							uint FramesOffset;
							uint FrameCount;
							int StartFrame;
							enum FOOT_FIT_INFO_FLAGS
							{
								FOOT_FIT_INFO_FLAGS_IS_LOOP = 0x1,
								FOOT_FIT_INFO_FLAGS_START_LEFT = 0x2, // Left foot first
							} Flags;

							if (FramesOffset != 0)
							{
								FSeek(startof(FramesOffset) + FramesOffset);
		
								uint Frames[FrameCount];
							}
						} Info;
							
						FSeek(startof(Info) + 0x10); // sizeof(MotionGraphFootFitInfo)
					} FootFitData;

					// A list of hashes which is seemingly unused but matches the StringParams used in event named 3487515216 (add anim graph tag).
					uint TagsOffset;
					uint TagCount;
					
					if (TagCount != 0)
					{
						FSeek(startof(TagsOffset) + TagsOffset);

						enum <uint64> TagString_StrCodeAlias
						{
							Hold = 10946689085138,
							Cqc = 15970714994597,
							Left = 168562599339607,
							Right = 186371849431182,
							Start = 256657689349378,
							Carry = 274098151722498,
							Damage = 43102718049991,
							DisableGunHold = 46337489715398,
							Idle = 61907898383491,
							DisableMove = 7660441078150,
							Cliff = 94765518158100,
							Stand = 134474105696778,
							Crawl = 167621566807970,
							AttachWeaponToLHand = 171276586778105,
							Supine = 207439181639403,
							Hung = 236773365968224,
							Squat = 80979382735191,
						} Tags[TagCount];
					}
				} Cache;
				break;
			default:
				Assert(false);
				break;
			}

			// Debug
			// local uint tgIdx = 0;
			// for (tgIdx = 0; tgIdx < TagCount; tgIdx++)
			// 	Printf("%Lu\n", Tags[tgIdx]);
		} Cache;
	}
} EvpData <read = EnumToString(CategoryName), bgcolor = 0x00C010>;

typedef struct
{
	uint Version <hidden = true>;

	short Count <hidden = true>;

	ushort Padding <hidden = true>; Assert(Padding == 0);

	uint EntryOffsets[Count] <hidden = true>;

	local uint eIdx;
	for (eIdx = 0; eIdx < Count; eIdx++)
	{
		FSeek(startof(this) + EntryOffsets[eIdx]);

		EvpData Data;
	}
} EvpHeader <bgcolor = 0x00C000>;

typedef enum <uint>
{
	TRACK_STREAM_FLAGS_HAS_EVENT_PACKET = 0x1,
	TRACK_STREAM_FLAGS_HAS_SEGMENT_FLAGS = 0x2,
	TRACK_STREAM_FLAGS_HAS_BASE_OFFSET = 0x4,
	TRACK_STREAM_FLAGS_HAS_EVENTS = 0x8,
} TRACK_STREAM_FLAGS <read = ReadTrackStreamFlags>;
string ReadTrackStreamFlags(TRACK_STREAM_FLAGS flags)
{
	local string result = flags == 0 ? "" : "| ";
	local ubyte i;
	local string enumName;
	local TRACK_STREAM_FLAGS temp;
	for (i = 1; i < 0x10; i = i << 1)
	{
		temp = flags & i;
		enumName = EnumToString(temp);
		if (enumName != "")
			result += " " + enumName + " |";
	}

	return result;
}

typedef enum <ushort>
{
	TRACK_STREAM_SEGMENT_FLAGS_IS_STATIC = 0x1,
	TRACK_STREAM_SEGMENT_FLAGS_NO_DATA = 0x2,
	TRACK_STREAM_SEGMENT_FLAGS_HAS_BASE_OFFSET = 0x4,
} TRACK_STREAM_SEGMENT_FLAGS <read = ReadTrackStreamSegmentFlags>;
string ReadTrackStreamSegmentFlags(TRACK_STREAM_SEGMENT_FLAGS flags)
{
	local string result = flags == 0 ? "" : "| ";
	local ubyte i;
	local string enumName;
	local TRACK_STREAM_SEGMENT_FLAGS temp;
	for (i = 1; i < 0x8; i = i << 1)
	{
		temp = flags & i;
		enumName = EnumToString(temp);
		if (enumName != "")
			result += " " + enumName + " |";
	}

	return result;
}

enum <uint> PACKET_TYPE
{
	PACKET_TYPE_STREAM = 0,
	PACKET_TYPE_NODES = 1, //GZ/PT/that unused FSM in TPP only
	PACKET_TYPE_EVENTS = 2,
};

struct FoxDataNodes;
struct PacketHeader
{
	PACKET_TYPE Type;
				
	uint NextPacketOffset;
	uint Padding <hidden = true>; Assert(Padding == 0);
	
	switch (Type)
	{
	case PACKET_TYPE_NODES:
		FoxDataNodes Nodes;
		break;
	case PACKET_TYPE_EVENTS:
		EvpData Events;
		break;
	}
};

struct TrackStream
{
	PACKET_TYPE Type;
	TRACK_STREAM_FLAGS Flags;
	uint StartFrame;
	uint FrameCount;

	uint SegmentCount;
	uint NextPacketOffset;
	uint EventsOffset;

	uint SegmentOffsets[SegmentCount];
	if ((Flags & TRACK_STREAM_FLAGS_HAS_BASE_OFFSET) != 0)
		Vector3 BaseOffset;

	if ((Flags & TRACK_STREAM_FLAGS_HAS_SEGMENT_FLAGS) != 0)
		TRACK_STREAM_SEGMENT_FLAGS SegmentFlags[SegmentCount];

	if ((Flags & TRACK_STREAM_FLAGS_HAS_EVENTS) != 0 && EventsOffset != 0)
	{
		FSeek(startof(this) + EventsOffset);
		EvpData Events;
	}
};


typedef enum <ubyte>
{
	A	=	0,
	AH	=	1,
	AY	=	2,
	B	=	3,
	C	=	4,
	CH	=	5,
	D	=	6,
	E	=	7,
	EE	=	8,
	ER	=	9,
	F	=	10,
	G	=	11,
	H	=	12,
	I	=	13,
	J	=	14,
	L	=	15,
	M	=	16,
	N	=	17,
	NG	=	18,
	OH	=	19,
	OO	=	20,
	OU	=	21,
	OW	=	22,
	OY	=	23,
	P	=	24,
	R	=	25,
	S	=	26,
	SH	=	27,
	T	=	28,
	TH	=	29,
	TT	=	30,
	U	=	31,
	V	=	32,
	W	=	33,
	Y	=	34,
	Z	=	35,
	_i	=	36,
	_tH	=	37,
} LipAnimIndex;

#endif
