#ifndef ANIM_COMMON_BT
#define ANIM_COMMON_BT

typedef struct
{
	ushort value <hidden = true>;
} AnimHalf <read = ReadAnimHalf>;
string ReadAnimHalf(AnimHalf& animHalf)
{
	local uint num1 = (animHalf.value & 0x7C00);
	if (num1 > 0)
		num1 = (num1 + 0x1A400) << 13;      
	num1 |= ((animHalf.value & 0x8000) << 16) | ((animHalf.value & 0x3FF) << 13);

	local ubyte value[4];
	value[0] = (ubyte)((num1 >> 0) & 0xFF);
	value[1] = (ubyte)((num1 >> 8) & 0xFF);
	value[2] = (ubyte)((num1 >> 16) & 0xFF);
	value[3] = (ubyte)((num1 >> 24) & 0xFF);

	float result = ConvertBytesToFloat(value);

	return Str("%f", result);
}

enum <ubyte> SEGMENT_TYPE
{
	SEGMENT_TYPE_QUAT = 0,
	SEGMENT_TYPE_FLOAT = 1,
	SEGMENT_TYPE_VECTOR2 = 2,
	SEGMENT_TYPE_VECTOR3 = 3,
	SEGMENT_TYPE_VECTOR4 = 4,
	SEGMENT_TYPE_QUAT_DIFF = 5,
	SEGMENT_TYPE_VECTOR_DIFF = 6,
};

typedef struct
{
	AnimHalf x;
	AnimHalf y;
	AnimHalf z;
} VectorAnimH3 <read = Str("(%s, %s, %s)", ReadAnimHalf(x), ReadAnimHalf(y), ReadAnimHalf(z))>;

typedef struct
{
	AnimHalf x;
	AnimHalf y;
	AnimHalf z;
	AnimHalf w;
} VectorAnimH4 <read = Str("(%s, %s, %s, %s)", ReadAnimHalf(x), ReadAnimHalf(y), ReadAnimHalf(z), ReadAnimHalf(w))>;

// These are not padded! BitfieldDisablePadding() needs to be called before using them. 
// The frame count after each instance is also not padded!
typedef struct
{
	ushort Theta : 12;
	ushort Y : 12;
	ushort Z : 12;
	ushort X_Sign : 1;
	ushort Y_Sign : 1;
	ushort Z_Sign : 1;
} QuatAnim12;

typedef struct
{
	ushort Theta : 13;
	ushort Y : 13;
	ushort Z : 13;
	ushort X_Sign : 1;
	ushort Y_Sign : 1;
	ushort Z_Sign : 1;
} QuatAnim13;

typedef struct
{
	ushort Theta : 15;
	ushort Y : 15;
	ushort Z : 15;
	ushort X_Sign : 1;
	ushort Y_Sign : 1;
	ushort Z_Sign : 1;
} QuatAnim15;

struct SegmentKeyframeData(SEGMENT_TYPE type, ubyte componentBitSize)
{
	switch (type)
	{
		case SEGMENT_TYPE_QUAT:
			switch (componentBitSize)
			{
			case 12:
				QuatAnim12 Value;
				break;
			case 13:
				QuatAnim13 Value;
				break;
			case 15:
				QuatAnim15 Value;
				break;
			default:
				Assert(false);
				break;
			}
			break;
		case SEGMENT_TYPE_FLOAT:
			switch (componentBitSize)
			{
			case 16:
				AnimHalf Value;
				break;
			case 32:
				float Value;
				break;
			default:
				Assert(false);
				break;
			}
			break;
		case SEGMENT_TYPE_VECTOR3:
			switch (componentBitSize)
			{
			case 0:
				break;
			case 16:
				VectorAnimH3 Value;
				break;
			case 32:
				Vector3 Value;
				break;
			default:
				Assert(false);
				break;
			}
			break;
		case SEGMENT_TYPE_VECTOR4:
			switch (componentBitSize)
			{
			case 16:
				VectorAnimH4 Value;
				break;
			case 32:
				Vector4 Value;
				break;
			default:
				Assert(false);
				break;
			}
			break;
		case SEGMENT_TYPE_QUAT_DIFF:
			switch (componentBitSize)
			{
			case 12:
				QuatAnim12 Value;
				break;
			case 15:
				QuatAnim15 Value;
				break;
			default:
				Assert(false);
				break;
			}
			break;
		case SEGMENT_TYPE_VECTOR_DIFF:
			switch (componentBitSize)
			{
			case 32:
				Vector3 Value;
				break;
			case 16:
				VectorAnimH3 Value;
				break;
			default:
				Assert(false);
				break;
			}
			break;
		default:
			Printf("@%Lx Unknown component bit size: %u\n", FTell(), componentBitSize);
			Assert(false);
			break;
	}
};

struct TrackDataBlob(SEGMENT_TYPE type, ubyte componentBitSize, ubyte isStatic)
{
	if (!(componentBitSize == 8 || componentBitSize == 16 || componentBitSize == 32 || componentBitSize == 64))
		BitfieldDisablePadding();
	SegmentKeyframeData FirstKey(type, componentBitSize);
	if (!(componentBitSize == 8 || componentBitSize == 16 || componentBitSize == 32 || componentBitSize == 64))
		BitfieldEnablePadding();

	if (!(componentBitSize == 8 || componentBitSize == 16 || componentBitSize == 32 || componentBitSize == 64))
		BitfieldDisablePadding();
	if (isStatic == 0)
	{
		local uint frameIndex = 0;
		do
		{
			struct AnimKeyframe(SEGMENT_TYPE type, ubyte componentBitSize)
			{
				ubyte FrameCount : 8;

				SegmentKeyframeData Data(type, componentBitSize);
			} Key(type, componentBitSize);

			frameIndex += Key.FrameCount;
		}
		while (frameIndex < FrameCount);
	}
	if (!(componentBitSize == 8 || componentBitSize == 16 || componentBitSize == 32 || componentBitSize == 64))
		BitfieldEnablePadding();

	FAlign(2);
};

typedef enum <ubyte>
{
	TRACK_UNIT_FLAGS_LOOP = 0x1,
	TRACK_UNIT_FLAGS_HERMITE_VECTOR_INTERPOLATION = 0x2,
	TRACK_UNIT_FLAGS_IS_STATIC = 0x4,
} TRACK_UNIT_FLAGS <read = ReadTrackUnitFlags>;
string ReadTrackUnitFlags(TRACK_UNIT_FLAGS flags)
{
	local string result = flags == 0 ? "" : "| ";
	local ubyte i;
	local string enumName;
	local TRACK_UNIT_FLAGS temp;
	for (i = 1; i < 0x8; i = i << 1)
	{
		temp = flags & i;
		enumName = EnumToString(temp);
		if (enumName != "")
			result += " " + enumName + " |";
	}

	return result;
}

local int disableTrackData = false;

typedef struct
{
	int UnitCount;

	uint SegmentCount;
	
	ushort Id;

	byte UnknownA <hidden = true>; Assert(UnknownA == 0);
	byte UnknownB; Assert(UnknownB == 1);

	uint FrameCount;

	byte FrameRate; FSkip(3);

	uint UnitOffsets[UnitCount] <hidden = true>;

	local uint trkIdx;
	local uint sgmIdx;
	for (trkIdx = 0; trkIdx < UnitCount; trkIdx++)
	{
		FSeek(startof(this) + UnitOffsets[trkIdx]);

		struct TrackUnit
		{
			// For SAND, hash of the sub object, like a bone, ie SKL_000_WAIST. For GANI, it's the name of a Motion Point.
			enum <uint> TrackName_StrCode32Alias
			{
				// CANI, UIA, etc.
				ROTATE          = 283103795,
				SCALE           = 2236677358,
				TRANSLATE       = 2739596730,
				COLOR           = 1662570759,
				
				//IK
				RIG_ROOT        = 3552837520,

				// MTAR
				TensionController = 2275904709,
				TensionShift = 2003538961,
				TensionRate = 853304191,

				// 
			} Name;

			ubyte SegmentCount; sgmIdx = sgmIdx + SegmentCount;

			TRACK_UNIT_FLAGS Flags;

			ushort Padding <hidden = true>; Assert(Padding == 0);

			struct TrackData
			{
				int DataOffset;

				short Id; // Segment id
				
				SEGMENT_TYPE Type : 4;

				ubyte NextEntryOffset : 4; Assert(NextEntryOffset == 0 || NextEntryOffset == 8); // The offset to the next entry is (NextEntryOffset & 0x8). since NextEntryOffset is always 0 or 8, this does nothing. 

				ubyte ComponentBitSize;
				
				if (DataOffset != 0 && !disableTrackData)
				{
					FSeek(startof(this) + DataOffset);

					TrackDataBlob Data(Type, ComponentBitSize, Flags & TRACK_UNIT_FLAGS_IS_STATIC);

					FSeek(startof(this) + NextEntryOffset);
				}
			} Segments[SegmentCount] <read = EnumToString(Type), optimize = false>;
		} Track;
	}
} TrackHeader <bgcolor = 0x8ADEF3>;

struct FoxDataName;
struct StringData
{
	uint EntryCount <hidden = true>;
	local int64 strIdx;
	for (strIdx = 0; strIdx < EntryCount; strIdx++)
	{
		FoxDataName Entry <optimize = true>;
	}
};

struct StringData2
{
	uint EntryCount <hidden = true>;
	local int64 strIdx;
	StrCode32 Entries[EntryCount] <optimize = true>;
};

enum <uint> NODE_TYPE
{
	NODE_TYPE_STRINGDATA = 0,
	NODE_TYPE_TRACKS = 1,
	NODE_TYPE_EVENTS = 3,
};

//Hack for PS3 files
typedef struct
{
	uint paramA <hidden=true>;
	uint paramB <hidden=true>;
	local StrCode param<format=hex>;
	param.hash = (uint64)paramA | ((uint64)paramB << 32);
} PARAM_STRING <read=Str("%I64u",param.hash)>; 

typedef struct
{
	enum <uint> EvfCategoryName_StrCode32Alias
	{
		Normal = 3371498678,
		ag = 2079928349,
		cc = 3342815349,
		fx = 2569337208,
		sd = 179473302,
		vo = 1455888052,
	} CategoryName;

	short UnitCount <hidden = true>;

	ushort CacheOffset;

	if (UnitCount != 0)
		uint UnitOffsets[UnitCount] <hidden = true>;

	local uint sIdx;
	for (sIdx = 0; sIdx < UnitCount; sIdx++)
	{
		FSeek(startof(this) + UnitOffsets[sIdx]);
		
		struct EventUnitInfo
		{
			enum <uint> EventUnitInfoEventName_StrCode32Alias
			{
				// fx
				FX_CREATE_EFFECT_WITH_SKL = 312449893,

				// ag
				MTEV_AG_SYNC_L = 877721620,
				MTEV_AG_SYNC_R = 3647133869,
				MTEV_FOOT_STOP_R = 2051014260,
				MTEV_FOOT_STOP_L = 4246579437,
				MTEV_FOOT_START_R = 3689287927,
				MTEV_FOOT_START_L = 3049626829,

				// sd
				right_foot_ground = 2122718581,
				right_foot_leave = 3453979597,
				left_foot_ground = 1190238672,
				left_foot_leave = 3446064903,
				rattle_weapon = 2416440354,
				rattle_suit = 1532442511,
				
				// Demo
				ExecCommand = 595181585,
				DemoStart = 3541589503,
				DemoEnd = 3534133658,
				CreateLocator = 2523762371,
				CreateModel = 3313525351,
				VisibleModel = 1040836537,
				VisibleMesh = 1799953944,
				DeleteLocator = 826863926,
				DeleteModel = 1968729831,
				CreateCamera = 2135789169,
				DeleteCamera = 4099945744,
				ClipEnd = 708232468,
			} EventName;
			
			//Printf(Str("%u\n",EventName));

			byte TimeSectionCount : 6 <hidden = true>;
			enum <byte> TIME_SECTION_FORMAT
			{
				TIME_SECTION_FORMAT_INT = 0,
				TIME_SECTION_FORMAT_SHORT = 1,
				TIME_SECTION_FORMAT_BYTE = 2,
				TIME_SECTION_FORMAT_INFINITE = 3,
			} Format : 2 <hidden = true>;

			byte IntParamCount <hidden = true>;
			byte FloatParamCount <hidden = true>;
			byte StringParamCount <hidden = true>;

			if (TimeSectionCount != 0)
			{
				struct TimeSection
				{
					switch (parentof(this).Format)
					{
					case TIME_SECTION_FORMAT_INT:
						int StartFrame <read = (this < 0 ? this : this & 0xBFFFFFFF)>;
						int EndFrame <read = (this < 0 ? this : this & 0xBFFFFFFF)>;
						break;
					case TIME_SECTION_FORMAT_SHORT:
						short StartFrame;
						short EndFrame;
						break;
					case TIME_SECTION_FORMAT_BYTE:
						byte StartFrame;
						byte EndFrame;
						break;
					case TIME_SECTION_FORMAT_INFINITE:
						break;
					}
					// This read function gets messy because of the formats but basically it's just saying TIME_SECTION_FORMAT_INFINITE -> (-1, 1), else to whatever the read function above is (which is only non-default for TYPE_INT).
				} TimeSections[TimeSectionCount] <read = (parentof(this).Format == TIME_SECTION_FORMAT_INFINITE ? "(-1, -1)" : Str("(%d, %d)", parentof(this).Format == TIME_SECTION_FORMAT_INT ? (StartFrame < 0 ? StartFrame : StartFrame & 0xBFFFFFFF) : StartFrame, parentof(this).Format == TIME_SECTION_FORMAT_INT ? (EndFrame < 0 ? EndFrame : EndFrame & 0xBFFFFFFF) : EndFrame)), optimize = true>;
			}

			FAlign(4);

			if (IntParamCount != 0)
				uint IntParams[IntParamCount];

			if (FloatParamCount != 0)
				float FloatParams[FloatParamCount];

			if (StringParamCount != 0)
			{
				PARAM_STRING StringParams[StringParamCount] <optimize = false>;
				//event string hash dump
				/*
				local uint stringIdx;
				for (stringIdx = 0; stringIdx < StringParamCount; stringIdx++)
				{
					Printf(Str("%I64u\n",StringParams[stringIdx].param.hash));
				}
				*/
				//vfx name dump
				/*
				if (EventName==595181585)
				{
					if (StringParamCount>7)
					{
						if (StringParams[6].param.hash==39224491583389
						||StringParams[6].param.hash==72256544285556
						||StringParams[6].param.hash==32886448170624
						||StringParams[7].param.hash==173102471356897
						||StringParams[6].param.hash==34251201099326)
						{
							Printf(Str("%I64u\n",StringParams[0].param.hash));
						};
					};
				}
				*/
				//human target hash dump
				/*if (EventName==1968729831)
				{
					if (StringParamCount!=0)
					{
						Printf(Str("%I64u\n",StringParams[0].param.hash));
					}
				}*/
				//mesh group hash dump
				/*if (EventName==1799953944)
				{
					Printf(Str("target: %I64u mesh group: %I64u\n",StringParams[0].param.hash,StringParams[1].param.hash));
				}*/
				//prp_ hash dump
				/*if (EventName==2523762371)
				{
					Printf(Str("%I64u\n",StringParams[0].param.hash));
				}*/
				if (EventName==595181585)
				{
					if (StringParamCount>6)
					{
						if (StringParams[5].param.hash==84993817083062) 
						{
							local float divisor = 0.6*1000/1001;
							Printf(Str("%f,%I64u\n",TimeSections[0].StartFrame/divisor,StringParams[1].param.hash));
						}
					}
				}
			}
		} Event <read = EnumToString(EventName)>;
	}

	if (CacheOffset != 0)
	{
		FSeek(startof(this) + CacheOffset);

		struct EventCache
		{
			uint IntParamsOffset;
			uint IntParamCount;

			uint FloatParamsOffset;
			uint FloatParamCount;

			uint StringParamsOffset;
			uint StringParamCount;

			if (IntParamsOffset != 0) Assert(IntParamCount != 0 && FTell() == startof(IntParamsOffset) + IntParamsOffset);
			if (IntParamCount != 0)
				uint IntParams[IntParamCount];

			if (FloatParamsOffset != 0) Assert(FloatParamCount != 0 && FTell() == startof(FloatParamsOffset) + FloatParamsOffset);
			if (FloatParamCount != 0)
				float FloatParams[FloatParamCount];

			if (StringParamsOffset != 0) Assert(StringParamCount != 0 && FTell() == startof(StringParamsOffset) + StringParamsOffset);
			if (StringParamCount != 0)
				StrCode StringParams[StringParamCount];
		} Cache;
	}
} EvpData <read = EnumToString(CategoryName), bgcolor = 0x00C010>;

typedef struct
{
	uint Version <hidden = true>;

	short Count <hidden = true>;

	ushort Padding; Assert(Padding == 0);

	uint EntryOffsets[Count] <hidden = true>;

	local uint eIdx;
	for (eIdx = 0; eIdx < Count; eIdx++)
	{
		FSeek(startof(this) + EntryOffsets[eIdx]);

		EvpData Data;
	}
} EvpHeader <bgcolor = 0x00C000>;

typedef enum <uint>
{
	TRACK_STREAM_FLAGS_HAS_EVENT_PACKET = 0x1,
	TRACK_STREAM_FLAGS_HAS_SEGMENT_FLAGS = 0x2,
	TRACK_STREAM_FLAGS_HAS_BASE_OFFSET = 0x4,
	TRACK_STREAM_FLAGS_HAS_EVENTS = 0x8,
} TRACK_STREAM_FLAGS <read = ReadTrackStreamFlags>;
string ReadTrackStreamFlags(TRACK_STREAM_FLAGS flags)
{
	local string result = flags == 0 ? "" : "| ";
	local ubyte i;
	local string enumName;
	local TRACK_STREAM_FLAGS temp;
	for (i = 1; i < 0x10; i = i << 1)
	{
		temp = flags & i;
		enumName = EnumToString(temp);
		if (enumName != "")
			result += " " + enumName + " |";
	}

	return result;
}

typedef enum <ushort>
{
	TRACK_STREAM_SEGMENT_FLAGS_IS_STATIC = 0x1,
	TRACK_STREAM_SEGMENT_FLAGS_NO_DATA = 0x2,
	TRACK_STREAM_SEGMENT_FLAGS_HAS_BASE_OFFSET = 0x4,
} TRACK_STREAM_SEGMENT_FLAGS <read = ReadTrackStreamSegmentFlags>;
string ReadTrackStreamSegmentFlags(TRACK_STREAM_SEGMENT_FLAGS flags)
{
	local string result = flags == 0 ? "" : "| ";
	local ubyte i;
	local string enumName;
	local TRACK_STREAM_SEGMENT_FLAGS temp;
	for (i = 1; i < 0x8; i = i << 1)
	{
		temp = flags & i;
		enumName = EnumToString(temp);
		if (enumName != "")
			result += " " + enumName + " |";
	}

	return result;
}

enum <uint> PACKET_TYPE
{
	PACKET_TYPE_STREAM = 0,
	PACKET_TYPE_NODES = 1, //GZ/PT/that unused FSM in TPP only
	PACKET_TYPE_EVENTS = 2,
};

struct FoxDataNodes;
struct PacketHeader
{
	PACKET_TYPE Type;
				
	uint NextPacketOffset;
	uint EventsOffset;
	
	switch (Type)
	{
	case PACKET_TYPE_NODES:
		FoxDataNodes Nodes;
		break;
	case PACKET_TYPE_EVENTS:
		EvpData events;
		break;
	}
};

struct TrackStream
{
	PACKET_TYPE Type;
	TRACK_STREAM_FLAGS Flags;
	uint StartFrame;
	uint FrameCount;

	uint SegmentCount;
	uint NextPacketOffset;
	uint EventsOffset;

	uint SegmentOffsets[SegmentCount];
	if ((Flags & TRACK_STREAM_FLAGS_HAS_BASE_OFFSET) != 0)
		Vector3 BaseOffset;

	if ((Flags & TRACK_STREAM_FLAGS_HAS_SEGMENT_FLAGS) != 0)
		TRACK_STREAM_SEGMENT_FLAGS SegmentFlags[SegmentCount];

	if ((Flags & TRACK_STREAM_FLAGS_HAS_EVENTS) != 0 && EventsOffset != 0)
	{
		FSeek(startof(this) + EventsOffset);
		EvpData Events;
	}
};


typedef enum <ubyte>
{
	A	=	0,
	AH	=	1,
	AY	=	2,
	B	=	3,
	C	=	4,
	CH	=	5,
	D	=	6,
	E	=	7,
	EE	=	8,
	ER	=	9,
	F	=	10,
	G	=	11,
	H	=	12,
	I	=	13,
	J	=	14,
	L	=	15,
	M	=	16,
	N	=	17,
	NG	=	18,
	OH	=	19,
	OO	=	20,
	OU	=	21,
	OW	=	22,
	OY	=	23,
	P	=	24,
	R	=	25,
	S	=	26,
	SH	=	27,
	T	=	28,
	TH	=	29,
	TT	=	30,
	U	=	31,
	V	=	32,
	W	=	33,
	Y	=	34,
	Z	=	35,
	_i	=	36,
	_tH	=	37,
} LipAnimIndex;

#endif
