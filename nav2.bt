LittleEndian();

#include "common/common.bt"

#define COLOR_HEADER 0xBED655
#define COLOR_CHUNKDESC 0xD9FCAC

#define COLOR_NAVIGATIONGRAPH 0x4F54F0
#define COLOR_NAVIGATIONGRAPH_POSITIONS 0x5F63F1
#define COLOR_NAVIGATIONGRAPH_NODES 0x6F73F2
#define COLOR_NAVIGATIONGRAPH_LINKS 0x878AF5
#define COLOR_NAVIGATIONGRAPH_EDGES 0x8F92F5
#define COLOR_NAVIGATIONGRAPH_ATTRIBUTES 0x9FA1F6
#define COLOR_NAVIGATIONGRAPH_NAVMESHINDICES 0xAFB1F8

#define COLOR_NAVMESHCHUNK 0xEBC05B
#define COLOR_NAVMESHCHUNK_POSITIONS 0xECC569
#define COLOR_NAVMESHCHUNK_MESHES 0xEECB78
#define COLOR_NAVMESHCHUNK_NEIGHBORINFO 0xF0D187

#define COLOR_SEGMENTGRAPH 0x3DC59B
#define COLOR_SEGMENTGRAPH_POSITIONS 0x4ECAA4
#define COLOR_SEGMENTGRAPH_NODES 0x60CFAD
#define COLOR_SEGMENTGRAPH_LINKS 0x71D4B6

#define COLOR_SEGMENTCHUNK 0xB844B7
#define COLOR_SEGMENTCHUNK_BOUNDS 0xC979A3
#define COLOR_SEGMENTCHUNK_SEGMENTS 0xE3B9AD

#define COLOR_ISLANDGRAPH 0x6083FF

#define COLOR_SEARCHSPACE 0x894E00
#define COLOR_SEARCHSPACE_BUCKETDESC 0xB58536
#define COLOR_SEARCHSPACE_BUCKET 0xE6AA89

enum <uint> CHUNK_TYPE
{
	CHUNK_TYPE_NAVIGATION_GRAPH = 0,
	CHUNK_TYPE_NAVMESH_CHUNK = 1,
	CHUNK_TYPE_SEGMENT_GRAPH = 3,
	CHUNK_TYPE_SEGMENT_CHUNK = 4
};

typedef struct
{
	ushort x;
	ushort y;
	ushort z;
} FixedDenominator3 <read = ReadFixedDenominator3String>;
string ReadFixedDenominator3String(FixedDenominator3& fixed)
{
    return Str("%f, %f, %f", (float)fixed.x / Header.Denominator.x, (float)fixed.y / Header.Denominator.y, (float)fixed.z / Header.Denominator.z);
}

typedef struct
{
	ushort x;
} FixedScalar <read = ReadFixedScalarString>;
string ReadFixedScalarString(FixedScalar& fixed)
{
    return Str("%f", (float)fixed.x / Header.WeightDenominator.x);
}

typedef struct // Custom name
{
	FixedDenominator3 Min;
	FixedDenominator3 Max;
} BoundingDesc <read = Str("Min: (%s), Max: (%s)", ReadFixedDenominator3String(Min), ReadFixedDenominator3String(Max))>;

typedef struct
{
    uint Index : 15;
    uint TileId : 16; //Top two bits are special - (+ 0x4000) is for reserved, (+ 0x8000) is for dynamic
    uint Padding : 1 <hidden = true>; Assert(Padding == 0);
} FileUid <optimize = false, read = Str("Index: %u, TileId: %u", Index, TileId)>;

typedef struct
{
    uint Index : 15;
    uint TileId : 16; //Top two bits are special - (+ 0x4000) is for reserved, (+ 0x8000) is for dynamic
    uint Padding : 1 <hidden = true>; Assert(Padding == 0);
} DataChunkUid <optimize = false, read = Str("Index: %u, TileId: %u", Index, TileId)>;

enum <ubyte> NAV2_FEATURE_FLAGS
{
	A = 1 << 0,
	B = 1 << 1,
	C = 1 << 2,
	D = 1 << 7,
};

struct FileHeader
{
	uint Version; Assert(Version == 201403241 || Version == 201403242);
	uint FileSize;
	uint ChunksOffset;
	uint ChunkCount;
	
	uint SearchSpaceOffset;
	FileUid _FileUid; // 141b16b8a
	uint IslandGraphsOffset;
	uint Unknown_CrossingTileLinkRelated; Assert(Unknown_CrossingTileLinkRelated == 0); // 141af67bf

	Vector3 Origin;

	uint ConnectTileInfosOffset;
	uint Padding0 <hidden = true>; Assert(Padding0 == 0);
	uint ChunkDescsOffset;
	uint ChunkDescsDataSize;
	
	uint Padding1 <hidden = true>; Assert(Padding1 == 0);
	uint Padding2 <hidden = true>; Assert(Padding2 == 0); 

	FixedDenominator3 Denominator;
	FixedScalar WeightDenominator;

	NAV2_FEATURE_FLAGS FeatureFlags; // 141b16b8a
	ubyte IslandGraphCount;
	ubyte Pre2014_UnknownIndex; Assert(Pre2014_UnknownIndex == 0); // Patched at runtime to be 0xFF if old file version - 141af52cc
	ubyte Padding3 <hidden = true>; Assert(Padding3 == 0); 
} Header <bgcolor = COLOR_HEADER>;

FSeek(Header.ChunkDescsOffset);	
struct
{
	uint EntryCount;

	struct 
	{
		struct ChunkDesc
		{
			DataChunkUid _DataChunkUid;

			uint DataOffset;
			CHUNK_TYPE Type : 8;
			uint DataSize : 16;
			uint Unknown : 8; Assert(Unknown == 0 || Unknown == 1 || Unknown == 2);
		} Descs[EntryCount] <read = EnumToString(Type), optimize = false>;
	} TypedChunkDescs[3] <optimize = false>;
} ChunkDescs <bgcolor = COLOR_CHUNKDESC>;

// fox::nav::NavigationGraphKind
enum <uint> NAVIGATION_GRAPH_KIND
{
	NAVIGATION_GRAPH_KIND_STATIC = 0,
	NAVIGATION_GRAPH_KIND_DYNAMIC = 1,
};

FSeek(Header.ChunksOffset);
struct NavigationGraphChunkHeader
{
	uint PositionsOffset;

	uint NodesOffset;
	uint EdgesOffset;

	uint LinkDataOffset;

	uint Padding0 <hidden = true>; Assert(Padding0 == 0);
	uint Padding1 <hidden = true>; Assert(Padding1 == 0);

	uint AttributesOffset;

	uint Padding2 <hidden = true>; Assert(Padding2 == 0);

	uint NavmeshIndicesOffset;

	ushort NodeCount;
	ushort EdgeCount;

	uint Padding3 <hidden = true>; Assert(Padding3 == 0);
	ushort Padding4 <hidden = true>; Assert(Padding4 == 0);

	ushort AttributeCount;

	FSeek(startof(this) + PositionsOffset);
	FixedDenominator3 Positions[NodeCount] <bgcolor = COLOR_NAVIGATIONGRAPH_POSITIONS>;
	
	FSeek(startof(this) + NodesOffset);
	struct NavigationGraphNodeDesc06
	{
		local long rewindPos = FTell();

		ushort LinkDataOffset;
		ushort SegmentIndex : 12;
		ushort LinkDataOffsetUpper : 4;
		ubyte InsideLinkCount;
		BitfieldDisablePadding();
		ubyte HasSegmentLink : 1;
		ubyte HasDataChunkLink : 1;
		ubyte HasTileLink : 1;
		NAVIGATION_GRAPH_KIND Kind : 2; Assert(Kind == NAVIGATION_GRAPH_KIND_STATIC);
		ubyte Padding : 3 <hidden = true>; Assert(Padding == 0);
		BitfieldEnablePadding();

		Assert(((HasSegmentLink + HasDataChunkLink + HasTileLink) & (~1)) == 0); // Asserts that exactly one or zero of the links are present
		// Printf("%d, %d, %d, %d\n", InsideLinkCount, HasSegmentLink, HasDataChunkLink, HasTileLink);
		
		FSeek(startof(parentof(this)) + parentof(this).LinkDataOffset + (LinkDataOffsetUpper * 16 + LinkDataOffset * 2));
		struct NavigationGraphInsideLinkDesc
		{
			ushort NodeIndex;
			ushort EdgeIndex;
		} InsideLinks[InsideLinkCount] <bgcolor = COLOR_NAVIGATIONGRAPH_LINKS>;

		if (HasSegmentLink)
		{
			struct NavigationGraphCrossingSegmentLinkDesc // Custom name
			{
				ushort NodeIndex;
			} CrossingSegmentLinkDesc <bgcolor = COLOR_NAVIGATIONGRAPH_LINKS>;
		}

		if (HasDataChunkLink)
		{
			struct NavigationGraphCrossingDataChunkLinkDesc // Custom name
			{
				ushort DataChunkId;
				ushort NodeIndex;
			} CrossingDataChunkLinkDesc <bgcolor = COLOR_NAVIGATIONGRAPH_LINKS>;
		}

		if (HasTileLink)
		{
			struct NavigationGraphCrossingTileLinkDesc
			{
				ushort TileId;
				ushort DataChunkId;
				ushort NodeIndex; Assert(NodeIndex == 0xFFFF); // Game patches index at runtime when resolving tile links
			} CrossingTileLinkDesc <bgcolor = COLOR_NAVIGATIONGRAPH_LINKS>;
		}

		FSeek(rewindPos + 6); // sizeof(NavigationGraphNodeDesc06) == 6
	} Nodes[NodeCount] <optimize = false, bgcolor = COLOR_NAVIGATIONGRAPH_NODES>;

	FSeek(startof(this) + EdgesOffset);
	struct NavigationGraphEdgeDesc06
	{
		FixedScalar Weight;
		BitfieldDisablePadding();
		ushort SegmentIndex : 12;
		NAVIGATION_GRAPH_KIND Kind : 2; Assert(Kind == NAVIGATION_GRAPH_KIND_STATIC);
		ushort Padding : 2 <hidden = true>; Assert(Padding == 0);
		BitfieldEnablePadding();

		ubyte NodeIndex0;
		ubyte NodeIndex1;
	} Edges[EdgeCount] <optimize = false, bgcolor = COLOR_NAVIGATIONGRAPH_EDGES>;

	FSeek(startof(this) + AttributesOffset);
	ushort Attributes[AttributeCount] <bgcolor = COLOR_NAVIGATIONGRAPH_ATTRIBUTES>;

	FSeek(startof(this) + NavmeshIndicesOffset);
	ushort NavmeshIndices[NodeCount] <bgcolor = COLOR_NAVIGATIONGRAPH_NAVMESHINDICES>; // GetNodeNavmeshHandle
};

enum <uint> NAVMESH_NEIGHBOR_TYPE
{
	NAVMESH_NEIGHBOR_TYPE_INSIDE = 0,
	NAVMESH_NEIGHBOR_TYPE_CROSSING_DATACHUNK = 1,
	NAVMESH_NEIGHBOR_TYPE_CROSSING_TILE = 2,
	NAVMESH_NEIGHBOR_TYPE_DYNAMIC = 3,
	NAVMESH_NEIGHBOR_TYPE_INVALID = 0xF,
};

struct NavmeshChunkHeader
{
	uint PositionsOffset;

	uint MeshesOffset;
	uint MeshDataOffset;
	
	uint64 Padding0 <hidden = true>; Assert(Padding0 == 0);
	uint Padding1 <hidden = true>; Assert(Padding1 == 0);

	ushort MeshCount;
	ushort PositionCount;

	uint Padding2 <hidden = true>; Assert(Padding2 == 0);

	FSeek(startof(this) + PositionsOffset);
	FixedDenominator3 Positions[PositionCount] <bgcolor = COLOR_NAVMESHCHUNK_POSITIONS>;

	FSeek(startof(this) + MeshesOffset);
	struct NavmeshDesc06
	{
		local long rewindPos = FTell();

		uint DataOffset : 18;
		uint Use4NeighborInfos : 1; // TODO; These have to be dynamic or something; the actual tests are always with triangles
		uint Use4NavigationGraphNodes : 1;
		uint SegmentIndex : 12;

		FSeek(startof(parentof(this)) + parentof(this).MeshDataOffset + DataOffset * 2);
		struct NeighborNavmeshInfo06
		{
			// Invalid if packed 16 bits are 0xFFFF
			BitfieldDisablePadding();
			ushort NavmeshIndex : 14;
			NAVMESH_NEIGHBOR_TYPE Type : 2;
			BitfieldEnablePadding();
		} NeighborNavmeshInfos[Use4NeighborInfos ? 4 : 3] <optimize = false, bgcolor = COLOR_NAVMESHCHUNK_NEIGHBORINFO>;

		ubyte NeighborPositionIndices[Use4NeighborInfos ? 4 : 3] <bgcolor = COLOR_NAVMESHCHUNK_NEIGHBORINFO>;

		ubyte NavigationGraphNodeIndices[Use4NavigationGraphNodes ? 4 : 3] <bgcolor = COLOR_NAVMESHCHUNK_NEIGHBORINFO>;

		ushort NeighborDataChunkIds[Use4NeighborInfos ? 4 : 3] <bgcolor = COLOR_NAVMESHCHUNK_NEIGHBORINFO>;

		ushort NeighborTileIds[Use4NeighborInfos ? 4 : 3] <bgcolor = COLOR_NAVMESHCHUNK_NEIGHBORINFO>;

		FSeek(rewindPos + 4); // sizeof(NavmeshDesc06) == 4
	} Meshes[MeshCount] <optimize = false, bgcolor = COLOR_NAVMESHCHUNK_MESHES>;
};

struct SegmentGraphChunkHeader
{
	uint PositionsOffset;
	uint NodesOffset;
	uint LinkDataOffset;

	uint Padding0 <hidden = true>; Assert(Padding0 == 0);
	uint SelfSize;
	ushort NodeCount;
	uint Padding1 <hidden = true>; Assert(Padding1 == 0);
	ushort TotalNavigationGraphNodeIndexCount; // Sum of all NavigationGraphNodeIndexCounts below
	uint Padding2 <hidden = true>; Assert(Padding2 == 0);

	FSeek(startof(this) + PositionsOffset);
	FixedDenominator3 Positions[NodeCount] <bgcolor = COLOR_SEGMENTGRAPH_POSITIONS>;

	FSeek(startof(this) + NodesOffset);
    struct SegmentGraphNodeDesc07
    {
		local long rewindPos = FTell();

		uint LinkDataOffset : 20;
		uint Unknown : 4; Assert(Unknown == 0);
		uint InsideLinkCount : 8;
		ushort IslandGraphNodeIndices[3]; // 3 == Header.IslandGraphCount - hardcoded, see 141b144b0
		ubyte CrossingDataChunkLinkCount;
		ubyte CrossingTileLinkCount;

		local long baseLinkDataOffset = startof(parentof(this)) + parentof(this).LinkDataOffset + (LinkDataOffset * 2);
		local long nodeIndicesOffset = baseLinkDataOffset + (InsideLinkCount * 6) + (CrossingDataChunkLinkCount * 8) + (CrossingTileLinkCount * 10); // Skip to end of the three link arrays; the node indices array is shared between all three link types
		FSeek(baseLinkDataOffset);
		struct SegmentGraphInsideLinkDesc // Custom name
		{
			local long rewindPos2 = startof(this);

			FixedScalar Weight;
			ushort NodeIndex;
			ubyte NavigationGraphNodeIndexCount;
			ubyte LinkIndex;

			FSeek(nodeIndicesOffset);
			ubyte NavigationGraphNodeIndices[NavigationGraphNodeIndexCount];
			nodeIndicesOffset += NavigationGraphNodeIndexCount;

			FSeek(rewindPos2 + 6); // sizeof(SegmentGraphInsideLinkDesc) == 6
		} InsideLinks[InsideLinkCount] <optimize = false, bgcolor = COLOR_SEGMENTGRAPH_LINKS>;

		struct SegmentGraphCrossingDataChunkLinkDesc // Custom name
		{
			local long rewindPos2 = startof(this);

			ushort DataChunkId;
			FixedScalar Weight;
			ushort NodeIndex;
			ubyte NavigationGraphNodeIndexCount;
			ubyte LinkIndex;

			FSeek(nodeIndicesOffset);
			ubyte NavigationGraphNodeIndices[NavigationGraphNodeIndexCount];
			nodeIndicesOffset += NavigationGraphNodeIndexCount;

			FSeek(rewindPos2 + 8); // sizeof(SegmentGraphCrossingDataChunkLinkDesc) == 8
		} CrossingDataChunkLinkDescs[CrossingDataChunkLinkCount] <optimize = false, bgcolor = COLOR_SEGMENTGRAPH_LINKS>;

		struct SegmentGraphCrossingTileLinkDesc06
		{
			local long rewindPos2 = startof(this);

			ushort TileId;
			ushort DataChunkId;
			FixedScalar Weight;
			ushort NodeIndex; Assert(NodeIndex == 0xFFF); // Game patches index at runtime when resolving tile links
			ubyte NavigationGraphNodeIndexCount;
			ubyte LinkIndex;

			FSeek(nodeIndicesOffset);
			ubyte NavigationGraphNodeIndices[NavigationGraphNodeIndexCount];
			nodeIndicesOffset += NavigationGraphNodeIndexCount;

			FSeek(rewindPos2 + 10); // sizeof(SegmentGraphCrossingTileLinkDesc06) == 10
		} CrossingTileLinkDescs[CrossingTileLinkCount] <optimize = false, bgcolor = COLOR_SEGMENTGRAPH_LINKS>;

		FSeek(rewindPos + 12); // sizeof(SegmentGraphNodeDesc07) == 12
	} Nodes[NodeCount] <optimize = false, bgcolor = COLOR_SEGMENTGRAPH_NODES>;
};

struct SegmentChunkHeader
{
	uint BoundsOffset;
	uint SegmentsOffset;
	uint SelfSize;
	uint SegmentCount;

	FSeek(startof(this) + BoundsOffset);
	BoundingDesc Bounds[SegmentCount] <bgcolor = COLOR_SEGMENTCHUNK_BOUNDS>;

	FSeek(startof(this) + SegmentsOffset);
	// Defines foundation for references to NavigationGraph and NavmeshChunk sections - indices can be 'serial' or 'local' ('serial' = 'local' + base index)
	struct SegmentDesc06
	{
		short BaseNavmeshPositionIndex;
		short BaseNavmeshIndex;
		short BaseNavigationGraphEdgeIndex;
		short BaseNavigationGraphNodeIndex;
		ubyte NavmeshPositionCount;
		ubyte NavmeshCount;
		ubyte NavigationGraphEdgeCount;
		ubyte NavigationGraphNodeCount;
	} Segments[SegmentCount] <bgcolor = COLOR_SEGMENTCHUNK_SEGMENTS>;
};

struct
{
	CHUNK_TYPE Type; Assert(Type < 5); 

	uint NextChunkOffset;
	uint DataOffset;
	
	DataChunkUid _DataChunkUid;
	 
	switch(Type)
	{
		case CHUNK_TYPE_NAVIGATION_GRAPH:
			FSeek(startof(this) + DataOffset);
			NavigationGraphChunkHeader Chunk <bgcolor = COLOR_NAVIGATIONGRAPH>;
			break;
		case CHUNK_TYPE_NAVMESH_CHUNK:
			FSeek(startof(this) + DataOffset);
			NavmeshChunkHeader Chunk <bgcolor = COLOR_NAVMESHCHUNK>;
			break;
		case CHUNK_TYPE_SEGMENT_GRAPH:
			FSeek(startof(this) + DataOffset);
			SegmentGraphChunkHeader Chunk <bgcolor = COLOR_SEGMENTGRAPH>;
			break;
		case CHUNK_TYPE_SEGMENT_CHUNK:
			FSeek(startof(this) + DataOffset);
			SegmentChunkHeader Chunk <bgcolor = COLOR_SEGMENTCHUNK>;
			break;
	};

	FSeek(startof(this) + NextChunkOffset);
} Chunks [Header.ChunkCount] <read = Str("%s, uid: {tileId: %u, dataChunkId: %u}", EnumToString(Type), _DataChunkUid.TileId, _DataChunkUid.Index), optimize = false, bgcolor = 0x5B1ED8>;

enum <uint> ISLAND_GRAPH_CONNECT_SIDE_INDEX
{
	ISLAND_GRAPH_CONNECT_SIDE_INDEX_0 = 0,
	ISLAND_GRAPH_CONNECT_SIDE_INDEX_1 = 1,
	ISLAND_GRAPH_CONNECT_SIDE_INDEX_2 = 2,
	ISLAND_GRAPH_CONNECT_SIDE_INDEX_3 = 3,
};

if (Header.IslandGraphsOffset)
{
	struct 
	{
		FSeek(Header.IslandGraphsOffset);

		local uint i = 0;
		for (i = 0; i < Header.IslandGraphCount; i++)
		{
			struct IslandGraphHeader
			{
				ushort NextGraphOffset;
				ushort NodesOffset;
				ushort NodeCount;
				ushort LinkDataOffset;
				ushort LowGraphNodeHandlesOffset;
				ushort SegmentCountsOffset;
				ushort ConnectSideInfoGroupsOffset;
				ushort ConnectSideInfosOffset;

				FSeek(startof(this) + NodesOffset);
				struct IslandGraphNodeDesc
				{
					local long rewindPos = FTell();

					FixedDenominator3 Position;
					ushort Attributes;
					ushort LinkDataOffset;
					ushort CrossingTileLinkCount;
					ubyte InsideLinkCount;
					ubyte CrossingDataChunkLinkCount;

					FSeek(startof(parentof(this)) + parentof(this).LinkDataOffset + LinkDataOffset);

					struct IslandGraphCrossingDataChunkLinkDesc // Custom name
					{
						DataChunkUid _DataChunkUid;
						FixedScalar Weight;
						ushort NodeIndex;
					} CrossingDataChunkLinkDescs[CrossingDataChunkLinkCount];

					struct IslandGraphInsideLinkDesc // Custom name
					{
						FixedScalar Weight;
						ushort NodeIndex;
					} InsideLinks[InsideLinkCount];
					
					struct IslandGraphCrossingTileLinkDesc  // Custom name
					{
						BitfieldDisablePadding();
						ushort ConnectSideInfoIndex : 14;
						ISLAND_GRAPH_CONNECT_SIDE_INDEX ConnectSideIndex : 2;
						BitfieldEnablePadding();
					} CrossingTileLinkDescs[CrossingTileLinkCount] <optimize = true>;

					FSeek(rewindPos + 14); // sizeof(IslandGraphNodeDesc) == 14
				} Nodes[NodeCount] <optimize = false>;

				FSeek(startof(this) + LowGraphNodeHandlesOffset);
				struct IslandGraphLowGraphNodeHandle
				{
					DataChunkUid _DataChunkUid;
					ushort SegmentGraphNodeIndex;
					ushort NavigationGraphNodeIndex;
				} LowGraphNodeHandles[NodeCount] <optimize = false>;

				FSeek(startof(this) + SegmentCountsOffset);
				// Seemingly unused in EXE. Each is the number of SegmentGraph nodes that reference the given IslandGraph node
				ushort SegmentCounts[NodeCount];

				local long baseConnectSideInfoGroupsOffset = startof(this) + ConnectSideInfoGroupsOffset;
				local long baseConnectSideInfosOffset = startof(this) + ConnectSideInfosOffset;
				FSeek(baseConnectSideInfoGroupsOffset);
				struct IslandGraphConnectSideInfoGroupDesc // Custom name
				{
					local long rewindPos = FTell();

					ushort TileId;
					ushort StartIndex;
					ushort Count;

					FSeek(baseConnectSideInfosOffset + StartIndex * 4); // sizeof(IslandGraphConnectSideInfoDesc) == 4
					struct IslandGraphConnectSideInfoDesc // Custom name
					{
						FixedScalar Weight;
						ushort NodeIndex;
					} ConnectSideInfos[Count];

					FSeek(rewindPos + 6); // sizeof(IslandGraphConnectSideInfoGroupDesc) == 6
				} ConnectSideInfoGroups[4] <optimize = false>;

				if (NextGraphOffset != 0)
					FSeek(startof(this) + NextGraphOffset);
			} IslandGraph <bgcolor = COLOR_ISLANDGRAPH>;
		}
	} IslandGraphs;
}

if (Header.SearchSpaceOffset != 0)
{
	FSeek(Header.SearchSpaceOffset);
	struct SearchSpace
	{
		local long selfOffset = startof(this);

		Vector3 Origin; 
		FixedScalar RangeY <read = Str("%f", (float)this.x / Header.Denominator.y)>;
		ushort Padding0 <hidden = true>; Assert(Padding0 == 0);

		uint BlockCountX;
		uint BlockCountY;
		uint BlockCountZ;
		uint BlockSizeXZ;

		uint BlockSizeY;
		uint BucketDescsOffset; Assert(BucketDescsOffset == 48);

		uint BucketEntriesOffset;
		uint ConnectTileInfosOffset;

		FSeek(startof(this) + BucketDescsOffset);
		struct SearchBucketDesc
		{
			uint StartOffset;
			ushort Count;
			ubyte MinY <read = Str("%f", (float)this * 256.0f / Header.Denominator.y + parentof(parentof(this)).Origin.y)>; // fox::nav::SearchSpace::GetBucketActualRangeY
			ubyte MaxY <read = Str("%f", (float)this * 256.0f / Header.Denominator.y + (1 / Header.Denominator.y) + parentof(parentof(this)).Origin.y)>; // ""
		} BucketDescs[BlockCountX * BlockCountY * BlockCountZ] < bgcolor = COLOR_SEARCHSPACE_BUCKETDESC>;

		Assert(FTell() == startof(this) + BucketEntriesOffset);

		struct
		{
			local int i;
			local int j;
			for (i = 0; i < BlockCountX * BlockCountY * BlockCountZ; i++) {
				FSeek(startof(BucketDescs[i]) + BucketDescs[i].StartOffset);

				for (j = 0; j < BucketDescs[i].Count; j++) {
					struct SearchBucketEntry
					{
						DataChunkUid _DataChunkUid;
						uint IndexCount;
						ushort SegmentIndices[IndexCount];
					} BucketEntry;
				}
			}
		} BucketEntries <bgcolor = COLOR_SEARCHSPACE_BUCKET>;

        FAlign(16);
		Assert(FTell() == selfOffset + ConnectTileInfosOffset);
	} _SearchSpace <bgcolor = COLOR_SEARCHSPACE>;
}

if (Header.ConnectTileInfosOffset != 0)
{
	FSeek(Header.ConnectTileInfosOffset);

	// See fox::nav::service::WorldService::ResolveConnectTileInfosWithName
	struct ConnectTileInfosHeader
	{
		local long headerOffset = startof(this);
		
		ushort GroupsOffset;
		ushort InfosOffset;
		ushort NodesOffset;
		ushort GroupCount;

		struct ConnectTileInfoNodeDesc
		{
			ushort NavigationGraphNodeIndex;
			ushort NavmeshIndex : 14;
			ushort NavmeshNeighborIndex : 2;
		};

		struct ConnectTileInfoDesc
		{
			ushort DataChunkId;
			ushort Count : 5;
			ushort StartOffset : 11;

			local int k;
			for (k = 0; k < Count; k++)
			{
				FSeek(headerOffset + (2 * NodesOffset) + (4 * StartOffset) + (k * 4)); // 4 == sizeof(ConnectTileInfoNodeDesc)
				ConnectTileInfoNodeDesc Node;
			}
		};

		struct ConnectTileInfoGroupDesc
		{
			StrCode32 Name;
			ushort Count : 5;
			ushort StartOffset : 11;

			local int j;
			for (j = 0; j < Count; j++)
			{
				FSeek(headerOffset + (2 * InfosOffset) + (4 * StartOffset) + (j * 4)); // 4 == sizeof(ConnectTileInfoDesc)
				ConnectTileInfoDesc Info;
			}
		};

		struct
		{
			local int i;
			for (i = 0; i < GroupCount; i++)
			{
				FSeek(headerOffset + (2 * GroupsOffset) + (i * 6)); // 6 == sizeof(ConnectTileInfoGroupDesc)
				ConnectTileInfoGroupDesc Group;
			}
		} Groups;
	} _ConnectTileInfosContainer;
}