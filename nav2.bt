LittleEndian();

#include "common/common.bt"

#define COLOR_HEADER 0xBED655
#define COLOR_CHUNKDESC 0xD9FCAC

#define COLOR_NAVIGATIONGRAPH 0x4F54F0
#define COLOR_NAVIGATIONGRAPH_POSITIONS 0x5F63F1
#define COLOR_NAVIGATIONGRAPH_NODES 0x6F73F2
#define COLOR_NAVIGATIONGRAPH_LINKS 0x878AF5
#define COLOR_NAVIGATIONGRAPH_EDGES 0x8F92F5
#define COLOR_NAVIGATIONGRAPH_ATTRIBUTES 0x9FA1F6
#define COLOR_NAVIGATIONGRAPH_NAVMESHINDICES 0xAFB1F8

#define COLOR_NAVMESHCHUNK 0xEBC05B
#define COLOR_NAVMESHCHUNK_POSITIONS 0xECC569
#define COLOR_NAVMESHCHUNK_MESHES 0xEECB78
#define COLOR_NAVMESHCHUNK_NEIGHBORINFO 0xF0D187

#define COLOR_SEGMENTGRAPH 0x3DC59B
#define COLOR_SEGMENTGRAPH_POSITIONS 0x4ECAA4
#define COLOR_SEGMENTGRAPH_NODES 0x60CFAD
#define COLOR_SEGMENTGRAPH_LINKS 0x71D4B6

#define COLOR_SEGMENTCHUNK 0xB844B7
#define COLOR_SEGMENTCHUNK_BOUNDS 0xC979A3
#define COLOR_SEGMENTCHUNK_SEGMENTS 0xE3B9AD

#define COLOR_ISLANDGRAPH 0x3C67FA
#define COLOR_ISLANDGRAPH_NODES 0x577DFF
#define COLOR_ISLANDGRAPH_LINKS 0x7391FA
#define COLOR_ISLANDGRAPH_LOWGRAPH_LINKS 0x8DA4F7
#define COLOR_ISLANDGRAPH_SEGMENTCOUNTS 0xA1B5FF
#define COLOR_ISLANDGRAPH_CONNECTSIDEGROUPS 0xACBDFA
#define COLOR_ISLANDGRAPH_CONNECTSIDEINFOS 0xBECBF7

#define COLOR_SEARCHSPACE 0x894E00
#define COLOR_SEARCHSPACE_BUCKETS 0xB58536
#define COLOR_SEARCHSPACE_BUCKETENTRIES 0xE6AA89

#define COLOR_CONNECTTILEINFO 0x7146a4
#define COLOR_CONNECTTILEINFO_GROUPS 0x9889cb
#define COLOR_CONNECTTILEINFO_INFOS 0xb1aadc
#define COLOR_CONNECTTILEINFO_NODES 0xddddf3

enum <uint> CHUNK_TYPE
{
	CHUNK_TYPE_NAVIGATION_GRAPH = 0,
	CHUNK_TYPE_NAVMESH_CHUNK = 1,
	CHUNK_TYPE_SEGMENT_GRAPH = 3,
	CHUNK_TYPE_SEGMENT_CHUNK = 4
};

typedef struct
{
	ushort x;
	ushort y;
	ushort z;
} FixedDenominator3 <read = ReadFixedDenominator3String>;
string ReadFixedDenominator3String(FixedDenominator3& fixed)
{
    return Str("%f, %f, %f", (float)fixed.x / Header.Denominator.x, (float)fixed.y / Header.Denominator.y, (float)fixed.z / Header.Denominator.z);
}

typedef struct
{
	ushort x;
} FixedScalar <read = ReadFixedScalarString>;
string ReadFixedScalarString(FixedScalar& fixed)
{
    return Str("%f", (float)fixed.x / Header.WeightDenominator.x);
}

typedef struct // Custom name
{
	FixedDenominator3 Min;
	FixedDenominator3 Max;
} BoundingDesc <read = Str("Min: (%s), Max: (%s)", ReadFixedDenominator3String(Min), ReadFixedDenominator3String(Max))>;

typedef struct
{
    uint Index : 15;
    uint TileId : 16; //Top two bits are special - (+ 0x4000) is for reserved, (+ 0x8000) is for dynamic
    uint Padding : 1 <hidden = true>; Assert(Padding == 0);
} FileUid <optimize = false, read = Str("Index: %u, TileId: %u", Index, TileId)>;

typedef struct
{
    uint Index : 15;
    uint TileId : 16; //Top two bits are special - (+ 0x4000) is for reserved, (+ 0x8000) is for dynamic
    uint Padding : 1 <hidden = true>; Assert(Padding == 0);
} DataChunkUid <optimize = false, read = Str("Index: %u, TileId: %u", Index, TileId)>;

enum <ubyte> NAV2_FEATURE_FLAGS
{
	A = 1 << 0,
	B = 1 << 1,
	C = 1 << 2,
	D = 1 << 7,
};

struct FileHeader
{
	uint Version; Assert(Version == 201403241 || Version == 201403242);
	uint FileSize;
	uint ChunksOffset;
	uint ChunkCount;
	
	uint SearchSpaceOffset;
	FileUid _FileUid; // 141b16b8a
	uint IslandGraphsOffset;
	uint Unknown_CrossingTileLinkRelated; Assert(Unknown_CrossingTileLinkRelated == 0); // 141af67bf

	Vector3 Origin;

	uint ConnectTileInfoOffset;
	uint Padding0 <hidden = true>; Assert(Padding0 == 0);
	uint ChunkDescsOffset;
	uint ChunkDescsDataSize;
	
	uint Padding1 <hidden = true>; Assert(Padding1 == 0);
	uint Padding2 <hidden = true>; Assert(Padding2 == 0); 

	FixedDenominator3 Denominator;
	FixedScalar WeightDenominator;

	NAV2_FEATURE_FLAGS FeatureFlags; // 141b16b8a
	ubyte IslandGraphCount;
	ubyte Pre2014_UnknownIndex; Assert(Pre2014_UnknownIndex == 0); // Patched at runtime to be 0xFF if old file version - 141af52cc
	ubyte Padding3 <hidden = true>; Assert(Padding3 == 0); 
} Header <bgcolor = COLOR_HEADER>;

FSeek(Header.ChunkDescsOffset);	
struct
{
	uint EntryCount;

	struct 
	{
		struct ChunkDesc
		{
			DataChunkUid _DataChunkUid;

			uint DataOffset;
			CHUNK_TYPE Type : 8;
			uint DataSize : 24;
		} Descs[EntryCount] <read = EnumToString(Type), optimize = false>;
	} TypedChunkDescs[3] <optimize = false>;
} ChunkDescs <bgcolor = COLOR_CHUNKDESC>;

// fox::nav::NavigationGraphKind
enum <uint> NAVIGATION_GRAPH_KIND
{
	NAVIGATION_GRAPH_KIND_STATIC = 0,
	NAVIGATION_GRAPH_KIND_DYNAMIC = 1,
};

FSeek(Header.ChunksOffset);
struct NavigationGraphChunkHeader
{
	uint PositionsOffset;

	uint NodesOffset;
	uint EdgesOffset;

	uint LinkDataOffset;

	uint Padding0 <hidden = true>; Assert(Padding0 == 0);
	uint Padding1 <hidden = true>; Assert(Padding1 == 0);

	uint AttributesOffset;

	uint Padding2 <hidden = true>; Assert(Padding2 == 0);

	uint NavmeshIndicesOffset;

	ushort NodeCount;
	ushort EdgeCount;

	uint Padding3 <hidden = true>; Assert(Padding3 == 0);
	ushort Padding4 <hidden = true>; Assert(Padding4 == 0);

	ushort AttributeCount;

	FSeek(startof(this) + PositionsOffset);
	FixedDenominator3 Positions[NodeCount] <bgcolor = COLOR_NAVIGATIONGRAPH_POSITIONS>;
	
	FSeek(startof(this) + NodesOffset);
	struct NavigationGraphNodeDesc06
	{
		local long rewindPos = FTell();

		ushort LinkDataOffset;
		ushort SegmentIndex : 12;
		ushort LinkDataOffsetUpper : 4;
		ubyte InsideLinkCount;
		BitfieldDisablePadding();
		ubyte HasCrossingSegmentLink : 1;
		ubyte HasCrossingDataChunkLink : 1;
		ubyte HasCrossingTileLink : 1;
		NAVIGATION_GRAPH_KIND Kind : 2; Assert(Kind == NAVIGATION_GRAPH_KIND_STATIC);
		ubyte Padding : 3 <hidden = true>; Assert(Padding == 0);
		BitfieldEnablePadding();

		Assert(((HasCrossingSegmentLink + HasCrossingDataChunkLink + HasCrossingTileLink) & (~1)) == 0); // Asserts that exactly one or zero of the links are present
		
		FSeek(startof(parentof(this)) + parentof(this).LinkDataOffset + (LinkDataOffsetUpper * 16 + LinkDataOffset * 2));
		struct NavigationGraphInsideLinkDesc
		{
			ushort NodeIndex;
			ushort EdgeIndex;
		} InsideLinks[InsideLinkCount] <bgcolor = COLOR_NAVIGATIONGRAPH_LINKS>;

		if (HasCrossingSegmentLink)
		{
			struct NavigationGraphCrossingSegmentLinkDesc // Custom name
			{
				ushort NodeIndex;
			} CrossingSegmentLinkDesc <bgcolor = COLOR_NAVIGATIONGRAPH_LINKS>;
		}

		if (HasCrossingDataChunkLink)
		{
			struct NavigationGraphCrossingDataChunkLinkDesc // Custom name
			{
				ushort DataChunkId;
				ushort NodeIndex;
			} CrossingDataChunkLinkDesc <bgcolor = COLOR_NAVIGATIONGRAPH_LINKS>;
		}

		if (HasCrossingTileLink)
		{
			struct NavigationGraphCrossingTileLinkDesc
			{
				ushort TileId;
				ushort DataChunkId;
				ushort NodeIndex; Assert(NodeIndex == 0xFFFF); // Game patches index at runtime when resolving tile links
			} CrossingTileLinkDesc <bgcolor = COLOR_NAVIGATIONGRAPH_LINKS>;
		}

		FSeek(rewindPos + 6); // sizeof(NavigationGraphNodeDesc06) == 6
	} Nodes[NodeCount] <optimize = false, bgcolor = COLOR_NAVIGATIONGRAPH_NODES>;

	FSeek(startof(this) + EdgesOffset);
	struct NavigationGraphEdgeDesc06
	{
		FixedScalar Weight;
		BitfieldDisablePadding();
		ushort SegmentIndex : 12;
		NAVIGATION_GRAPH_KIND Kind : 2; Assert(Kind == NAVIGATION_GRAPH_KIND_STATIC);
		ushort Padding : 2 <hidden = true>; Assert(Padding == 0);
		BitfieldEnablePadding();

		ubyte NodeIndex0;
		ubyte NodeIndex1;
	} Edges[EdgeCount] <optimize = false, bgcolor = COLOR_NAVIGATIONGRAPH_EDGES>;

	FSeek(startof(this) + AttributesOffset);
	ushort Attributes[AttributeCount] <bgcolor = COLOR_NAVIGATIONGRAPH_ATTRIBUTES>;

	FSeek(startof(this) + NavmeshIndicesOffset);
	ushort NavmeshIndices[NodeCount] <bgcolor = COLOR_NAVIGATIONGRAPH_NAVMESHINDICES>; // GetNodeNavmeshHandle
};

enum <uint> NAVMESH_NEIGHBOR_TYPE
{
	NAVMESH_NEIGHBOR_TYPE_INSIDE = 0,
	NAVMESH_NEIGHBOR_TYPE_CROSSING_DATACHUNK = 1,
	NAVMESH_NEIGHBOR_TYPE_CROSSING_TILE = 2,
	NAVMESH_NEIGHBOR_TYPE_DYNAMIC = 3,
	NAVMESH_NEIGHBOR_TYPE_INVALID = 0xF,
};

struct NavmeshChunkHeader
{
	uint PositionsOffset;

	uint MeshesOffset;
	uint MeshDataOffset;
	
	uint64 Padding0 <hidden = true>; Assert(Padding0 == 0);
	uint Padding1 <hidden = true>; Assert(Padding1 == 0);

	ushort MeshCount;
	ushort PositionCount;

	uint Padding2 <hidden = true>; Assert(Padding2 == 0);

	FSeek(startof(this) + PositionsOffset);
	FixedDenominator3 Positions[PositionCount] <bgcolor = COLOR_NAVMESHCHUNK_POSITIONS>;

	FSeek(startof(this) + MeshesOffset);
	struct NavmeshDesc06
	{
		local long rewindPos = FTell();

		uint DataOffset : 18;
		uint Use4NeighborInfos : 1; // TODO; These have to be dynamic or something; the actual tests are always with triangles - check IntersectTriangleAABB
		uint Use4NavigationGraphNodes : 1;
		uint SegmentIndex : 12;

		FSeek(startof(parentof(this)) + parentof(this).MeshDataOffset + DataOffset * 2);
		struct NeighborNavmeshInfo06
		{
			// Invalid if packed 16 bits are 0xFFFF
			BitfieldDisablePadding();
			ushort NavmeshIndex : 14;
			NAVMESH_NEIGHBOR_TYPE Type : 2;
			BitfieldEnablePadding();
		} NeighborNavmeshInfos[Use4NeighborInfos ? 4 : 3] <optimize = false, bgcolor = COLOR_NAVMESHCHUNK_NEIGHBORINFO>;

		ubyte NeighborPositionIndices[Use4NeighborInfos ? 4 : 3] <bgcolor = COLOR_NAVMESHCHUNK_NEIGHBORINFO>;

		ubyte NavigationGraphNodeIndices[Use4NavigationGraphNodes ? 4 : 3] <bgcolor = COLOR_NAVMESHCHUNK_NEIGHBORINFO>;

		ushort NeighborDataChunkIds[Use4NeighborInfos ? 4 : 3] <bgcolor = COLOR_NAVMESHCHUNK_NEIGHBORINFO>;

		ushort NeighborTileIds[Use4NeighborInfos ? 4 : 3] <bgcolor = COLOR_NAVMESHCHUNK_NEIGHBORINFO>;

		FSeek(rewindPos + 4); // sizeof(NavmeshDesc06) == 4
	} Meshes[MeshCount] <optimize = false, bgcolor = COLOR_NAVMESHCHUNK_MESHES>;
};

struct SegmentGraphChunkHeader
{
	uint PositionsOffset;
	uint NodesOffset;
	uint LinkDataOffset;

	uint Padding0 <hidden = true>; Assert(Padding0 == 0);
	uint SelfSize;
	ushort NodeCount;
	uint Padding1 <hidden = true>; Assert(Padding1 == 0);
	ushort TotalNavigationGraphNodeIndexCount; // Sum of all NavigationGraphNodeIndexCounts below
	uint Padding2 <hidden = true>; Assert(Padding2 == 0);

	// For assertions
	local long totalInsideLinkCount = 0;
	local long totalCrossingDataChunkLinkCount = 0;
	local long totalCrossingTileLinkCount = 0;
	local long totalNavigationGraphNodeIndexCount = 0;

	FSeek(startof(this) + PositionsOffset);
	FixedDenominator3 Positions[NodeCount] <bgcolor = COLOR_SEGMENTGRAPH_POSITIONS>;

	FSeek(startof(this) + NodesOffset);
    struct SegmentGraphNodeDesc07
    {
		local long rewindPos = FTell();

		uint LinkDataOffset : 20;
		uint Unknown : 4; Assert(Unknown == 0);
		uint InsideLinkCount : 8; totalInsideLinkCount += InsideLinkCount;
		ushort IslandGraphNodeIndices[3]; // 3 == Header.IslandGraphCount - hardcoded, see 141b144b0
		ubyte CrossingDataChunkLinkCount; totalCrossingDataChunkLinkCount += CrossingDataChunkLinkCount;
		ubyte CrossingTileLinkCount; totalCrossingTileLinkCount += CrossingTileLinkCount;

		local long baseLinkDataOffset = startof(parentof(this)) + parentof(this).LinkDataOffset + (LinkDataOffset * 2);
		local long nodeIndicesOffset = baseLinkDataOffset + (InsideLinkCount * 6) + (CrossingDataChunkLinkCount * 8) + (CrossingTileLinkCount * 10); // Skip to end of the three link arrays; the node indices array is shared between all three link types
		FSeek(baseLinkDataOffset);
		struct SegmentGraphInsideLinkDesc // Custom name
		{
			local long rewindPos2 = startof(this);

			FixedScalar Weight;
			ushort NodeIndex;
			ubyte NavigationGraphNodeIndexCount; totalNavigationGraphNodeIndexCount += NavigationGraphNodeIndexCount;
			ubyte LinkIndex;

			FSeek(nodeIndicesOffset);
			ubyte NavigationGraphNodeIndices[NavigationGraphNodeIndexCount];
			nodeIndicesOffset += NavigationGraphNodeIndexCount;

			FSeek(rewindPos2 + 6); // sizeof(SegmentGraphInsideLinkDesc) == 6
		} InsideLinks[InsideLinkCount] <optimize = false, bgcolor = COLOR_SEGMENTGRAPH_LINKS>;

		struct SegmentGraphCrossingDataChunkLinkDesc // Custom name
		{
			local long rewindPos2 = startof(this);

			ushort DataChunkId;
			FixedScalar Weight;
			ushort NodeIndex;
			ubyte NavigationGraphNodeIndexCount; totalNavigationGraphNodeIndexCount += NavigationGraphNodeIndexCount;
			ubyte LinkIndex;

			FSeek(nodeIndicesOffset);
			ubyte NavigationGraphNodeIndices[NavigationGraphNodeIndexCount];
			nodeIndicesOffset += NavigationGraphNodeIndexCount;

			FSeek(rewindPos2 + 8); // sizeof(SegmentGraphCrossingDataChunkLinkDesc) == 8
		} CrossingDataChunkLinkDescs[CrossingDataChunkLinkCount] <optimize = false, bgcolor = COLOR_SEGMENTGRAPH_LINKS>;

		struct SegmentGraphCrossingTileLinkDesc06
		{
			local long rewindPos2 = startof(this);

			ushort TileId;
			ushort DataChunkId;
			FixedScalar Weight;
			ushort NodeIndex; Assert(NodeIndex == 0xFFF); // Game patches index at runtime when resolving tile links
			ubyte NavigationGraphNodeIndexCount; totalNavigationGraphNodeIndexCount += NavigationGraphNodeIndexCount;
			ubyte LinkIndex;

			FSeek(nodeIndicesOffset);
			ubyte NavigationGraphNodeIndices[NavigationGraphNodeIndexCount];
			nodeIndicesOffset += NavigationGraphNodeIndexCount;

			FSeek(rewindPos2 + 10); // sizeof(SegmentGraphCrossingTileLinkDesc06) == 10
		} CrossingTileLinkDescs[CrossingTileLinkCount] <optimize = false, bgcolor = COLOR_SEGMENTGRAPH_LINKS>;

		FSeek(rewindPos + 12); // sizeof(SegmentGraphNodeDesc07) == 12
	} Nodes[NodeCount] <optimize = false, bgcolor = COLOR_SEGMENTGRAPH_NODES>;

	// For assertions - doesn't work because nodes and links are aligned locally so there are some extra bytes for alignment padding
	// FSeek(startof(this) + LinkDataOffset + (totalInsideLinkCount * 6) + (totalCrossingDataChunkLinkCount * 8) + (totalCrossingTileLinkCount * 10) + TotalNavigationGraphNodeIndexCount); // sizeof(SearchBucketEntry) == 8
	// FAlign(16);
	// Assert(FTell() == startof(this) + SelfSize);
	Assert(totalNavigationGraphNodeIndexCount == TotalNavigationGraphNodeIndexCount);
};

struct SegmentChunkHeader
{
	uint BoundsOffset;
	uint SegmentsOffset;
	uint SelfSize;
	uint SegmentCount;

	FSeek(startof(this) + BoundsOffset);
	BoundingDesc Bounds[SegmentCount] <bgcolor = COLOR_SEGMENTCHUNK_BOUNDS>;

	FSeek(startof(this) + SegmentsOffset);
	// Defines foundation for references to NavigationGraph and NavmeshChunk sections - indices can be 'serial' or 'local' ('serial' = 'local' + base index)
	struct SegmentDesc06
	{
		short BaseNavmeshPositionIndex;
		short BaseNavmeshIndex;
		short BaseNavigationGraphEdgeIndex;
		short BaseNavigationGraphNodeIndex;
		ubyte NavmeshPositionCount;
		ubyte NavmeshCount;
		ubyte NavigationGraphEdgeCount;
		ubyte NavigationGraphNodeCount;
	} Segments[SegmentCount] <bgcolor = COLOR_SEGMENTCHUNK_SEGMENTS>;

	// For assertions
	FAlign(16);
	Assert(FTell() == startof(this) + SelfSize);
};

struct
{
	CHUNK_TYPE Type; Assert(Type < 5); 

	uint NextChunkOffset;
	uint DataOffset;
	
	DataChunkUid _DataChunkUid;
	 
	switch(Type)
	{
		case CHUNK_TYPE_NAVIGATION_GRAPH:
			FSeek(startof(this) + DataOffset);
			NavigationGraphChunkHeader Chunk <bgcolor = COLOR_NAVIGATIONGRAPH>;
			break;
		case CHUNK_TYPE_NAVMESH_CHUNK:
			FSeek(startof(this) + DataOffset);
			NavmeshChunkHeader Chunk <bgcolor = COLOR_NAVMESHCHUNK>;
			break;
		case CHUNK_TYPE_SEGMENT_GRAPH:
			FSeek(startof(this) + DataOffset);
			SegmentGraphChunkHeader Chunk <bgcolor = COLOR_SEGMENTGRAPH>;
			break;
		case CHUNK_TYPE_SEGMENT_CHUNK:
			FSeek(startof(this) + DataOffset);
			SegmentChunkHeader Chunk <bgcolor = COLOR_SEGMENTCHUNK>;
			break;
	};

	FSeek(startof(this) + NextChunkOffset);
} Chunks [Header.ChunkCount] <read = Str("%s, uid: {tileId: %u, dataChunkId: %u}", EnumToString(Type), _DataChunkUid.TileId, _DataChunkUid.Index), optimize = false, bgcolor = 0x5B1ED8>;

enum <uint> ISLAND_GRAPH_CONNECT_SIDE_INDEX
{
	ISLAND_GRAPH_CONNECT_SIDE_INDEX_0 = 0,
	ISLAND_GRAPH_CONNECT_SIDE_INDEX_1 = 1,
	ISLAND_GRAPH_CONNECT_SIDE_INDEX_2 = 2,
	ISLAND_GRAPH_CONNECT_SIDE_INDEX_3 = 3,
};

if (Header.IslandGraphsOffset)
{
	struct 
	{
		FSeek(Header.IslandGraphsOffset);

		local uint i = 0;
		for (i = 0; i < Header.IslandGraphCount; i++)
		{
			struct IslandGraphHeader
			{
				ushort NextGraphOffset;
				ushort NodesOffset;
				ushort NodeCount;
				ushort LinkDataOffset;
				ushort LowGraphNodeLinksOffset;
				ushort SegmentCountsOffset;
				ushort ConnectSideInfoGroupsOffset;
				ushort ConnectSideInfosOffset;

				FSeek(startof(this) + NodesOffset);
				struct IslandGraphNodeDesc
				{
					local long rewindPos = FTell();

					FixedDenominator3 Position;
					ushort Attributes;
					ushort LinkDataOffset;
					ushort CrossingTileLinkCount;
					ubyte InsideLinkCount;
					ubyte CrossingDataChunkLinkCount;

					FSeek(startof(parentof(this)) + parentof(this).LinkDataOffset + LinkDataOffset);

					struct IslandGraphCrossingDataChunkLinkDesc // Custom name
					{
						DataChunkUid _DataChunkUid;
						FixedScalar Weight;
						ushort NodeIndex;
					} CrossingDataChunkLinkDescs[CrossingDataChunkLinkCount] <bgcolor = COLOR_ISLANDGRAPH_LINKS>;

					struct IslandGraphInsideLinkDesc // Custom name
					{
						FixedScalar Weight;
						ushort NodeIndex;
					} InsideLinks[InsideLinkCount] <bgcolor = COLOR_ISLANDGRAPH_LINKS>;
					
					struct IslandGraphCrossingTileLinkDesc  // Custom name
					{
						BitfieldDisablePadding();
						ushort ConnectSideInfoIndex : 14;
						ISLAND_GRAPH_CONNECT_SIDE_INDEX ConnectSideIndex : 2;
						BitfieldEnablePadding();
					} CrossingTileLinkDescs[CrossingTileLinkCount] <optimize = true, bgcolor = COLOR_ISLANDGRAPH_LINKS>;

					FSeek(rewindPos + 14); // sizeof(IslandGraphNodeDesc) == 14
				} Nodes[NodeCount] <optimize = false, bgcolor = COLOR_ISLANDGRAPH_NODES>;

				FSeek(startof(this) + LowGraphNodeLinksOffset);
				struct IslandGraphLowGraphNodeLinkDesc // Custom name - comes from IslandGraphLowGraphNodeHandle which is identical but I made a new struct name here because "handle" feels runtime-specific
				{
					DataChunkUid _DataChunkUid;
					ushort SegmentGraphNodeIndex;
					ushort NavigationGraphNodeIndex;
				} LowGraphNodeLinks[NodeCount] <optimize = false, bgcolor = COLOR_ISLANDGRAPH_LOWGRAPH_LINKS>;

				FSeek(startof(this) + SegmentCountsOffset);
				// Seemingly unused in EXE. Each is the number of SegmentGraph nodes that reference the given IslandGraph node
				ushort SegmentCounts[NodeCount] <bgcolor = COLOR_ISLANDGRAPH_SEGMENTCOUNTS>;

				local long baseConnectSideInfoGroupsOffset = startof(this) + ConnectSideInfoGroupsOffset;
				local long baseConnectSideInfosOffset = startof(this) + ConnectSideInfosOffset;
				FSeek(baseConnectSideInfoGroupsOffset);
				struct IslandGraphConnectSideInfoGroupDesc // Custom name
				{
					local long rewindPos = FTell();

					ushort TileId;
					ushort StartIndex;
					ushort Count;

					FSeek(baseConnectSideInfosOffset + StartIndex * 4); // sizeof(IslandGraphConnectSideInfoDesc) == 4
					struct IslandGraphConnectSideInfoDesc // Custom name
					{
						FixedScalar Weight;
						ushort NodeIndex;
					} ConnectSideInfos[Count] <bgcolor = COLOR_ISLANDGRAPH_CONNECTSIDEGROUPS>;

					FSeek(rewindPos + 6); // sizeof(IslandGraphConnectSideInfoGroupDesc) == 6
				} ConnectSideInfoGroups[4] <optimize = false, bgcolor = COLOR_ISLANDGRAPH_CONNECTSIDEGROUPS>;

				if (NextGraphOffset != 0)
					FSeek(startof(this) + NextGraphOffset);
			} IslandGraph <bgcolor = COLOR_ISLANDGRAPH>;
		}
	} IslandGraphs;
}

if (Header.SearchSpaceOffset != 0)
{
	FSeek(Header.SearchSpaceOffset);
	struct SearchSpaceHeader
	{
		Vector3 Origin; 
		FixedScalar RangeY <read = Str("%f", (float)this.x / Header.Denominator.y)>;
		ushort Padding0 <hidden = true>; Assert(Padding0 == 0);

		uint BlockCountX;
		uint BlockCountY;
		uint BlockCountZ;
		uint BlockSizeXZ;

		uint BlockSizeY;
		uint BucketDescsOffset;
		uint BucketEntriesOffset;
		uint SelfSize;

		// For assertions
		local long totalBucketEntryCount = 0;
		local long totalSegmentIndexCount = 0;

		FSeek(startof(this) + BucketDescsOffset);
		struct SearchBucketDesc
		{
			local long rewindPos = FTell();

			uint StartOffset;
			ushort Count; totalBucketEntryCount += Count;
			ubyte MinY <read = Str("%f", (float)this * 256.0f / Header.Denominator.y + parentof(parentof(this)).Origin.y)>; // fox::nav::SearchSpace::GetBucketActualRangeY
			ubyte MaxY <read = Str("%f", (float)this * 256.0f / Header.Denominator.y + (1 / Header.Denominator.y) + parentof(parentof(this)).Origin.y)>; // ""

			FSeek(startof(this) + StartOffset);
			struct SearchBucketEntry
			{
				DataChunkUid _DataChunkUid;
				uint SegmentCount; totalSegmentIndexCount += SegmentCount;

				ushort SegmentIndices[SegmentCount];
			} BucketEntries[Count] <optimize = false, bgcolor = COLOR_SEARCHSPACE_BUCKETENTRIES>;

			FSeek(rewindPos + 8); // sizeof(SearchBucketDesc) == 8
		} BucketDescs[BlockCountX * BlockCountY * BlockCountZ] <optimize = false, bgcolor = COLOR_SEARCHSPACE_BUCKETS>;

		// For assertions
		FSeek(startof(this) + BucketEntriesOffset + totalBucketEntryCount * 8 + totalSegmentIndexCount * 2); // sizeof(SearchBucketEntry) == 8
		FAlign(16);
		Assert(FTell() == startof(this) + SelfSize);
	} SearchSpace <bgcolor = COLOR_SEARCHSPACE>;
}

if (Header.ConnectTileInfoOffset != 0)
{
	FSeek(Header.ConnectTileInfoOffset);
	struct ConnectTileInfoHeader // Custom name
	{
		local long baseOffset = startof(this);
		
		ushort GroupsOffset;
		ushort InfosOffset;
		ushort NodesOffset;
		ushort GroupCount;
		ushort InfoCount;
		ushort NodeCount;

		local long baseGroupsOffset = baseOffset + (2 * GroupsOffset);
		local long baseInfosOffset = baseOffset + (2 * InfosOffset);
		FSeek(baseGroupsOffset);
		struct ConnectTileInfoGroupDesc
		{
			local long rewindPos = FTell();

			StrCode32 Name;
			ushort Count : 5;
			ushort StartIndex : 11;

			FSeek(baseOffset + (2 * InfosOffset) + (StartIndex * 4)); // sizeof(ConnectTileInfoDesc) == 4
			struct ConnectTileInfoDesc
			{
				local long rewindPos2 = FTell();

				ushort DataChunkId;
				ushort Count : 5;
				ushort StartIndex : 11;

				FSeek(baseOffset + (2 * NodesOffset) + (StartIndex * 4)); // sizeof(ConnectTileInfoNodeDesc) == 4
				struct ConnectTileInfoNodeDesc
				{
					ushort NavigationGraphNodeIndex;
					ushort NavmeshIndex : 14;
					ushort NavmeshNeighborIndex : 2;
				} Nodes[Count] <bgcolor = COLOR_CONNECTTILEINFO_NODES>;

				FSeek(rewindPos2 + 4); // sizeof(ConnectTileInfoDesc) == 4
			} ConnectTileInfoDescs[Count] <optimize = false, bgcolor = COLOR_CONNECTTILEINFO_INFOS>;

			FSeek(rewindPos + 6); // sizeof(ConnectTileInfoGroupDesc) == 6
		} Groups[GroupCount] <optimize = false, bgcolor = COLOR_CONNECTTILEINFO_GROUPS>;
	} ConnectTileInfo <bgcolor = COLOR_CONNECTTILEINFO>;
}