LittleEndian();

#include "common/common.bt"

#define COLOR_HEADER 0xBED655
#define COLOR_CHUNKDESC 0xD9FCAC

#define COLOR_NAVIGATIONGRAPH 0x4F54F0
#define COLOR_NAVIGATIONGRAPH_VERTICES 0x5F63F1
#define COLOR_NAVIGATIONGRAPH_NODES 0x6F73F2
#define COLOR_NAVIGATIONGRAPH_SS3 0x7F82F4
#define COLOR_NAVIGATIONGRAPH_SS4 0x8F92F5
#define COLOR_NAVIGATIONGRAPH_SS5 0x9FA1F6
#define COLOR_NAVIGATIONGRAPH_SS6 0xAFB1F8

#define COLOR_NAVMESHCHUNK 0xEBC05B
#define COLOR_NAVMESHCHUNK_SS1 0xECC569
#define COLOR_NAVMESHCHUNK_SS2 0xEECB78
#define COLOR_NAVMESHCHUNK_SS3 0xF0D187

#define COLOR_SEGMENTGRAPH 0x3DC59B
#define COLOR_SEGMENTGRAPH_VERTICES 0x4ECAA4
#define COLOR_SEGMENTGRAPH_NODES 0x60CFAD
#define COLOR_SEGMENTGRAPH_SS3 0x71D4B6

#define COLOR_SEGMENTCHUNK 0xB844B7
#define COLOR_SEGMENTCHUNK_BOUNDS 0xC979A3
#define COLOR_SEGMENTCHUNK_SEGMENTS 0xE3B9AD

#define COLOR_ISLANDGRAPH 0x6083FF

#define COLOR_SEARCHSPACE 0x894E00
#define COLOR_SEARCHSPACE_BUCKETDESC 0xB58536
#define COLOR_SEARCHSPACE_BUCKET 0xE6AA89

typedef ubyte TWENTYFOURBITUINT[3] <read=TWENTYFOURBITUINTRead>;

string TWENTYFOURBITUINTRead( TWENTYFOURBITUINT n )
{
	string s;
	uint val = (uint)(n[0]) + (((uint)n[1]) << 8) + (((uint)n[2]) << 16);
	SPrintf( s, "%u", val);
	return s;
}

struct IndexPair8
{
	ubyte from;
	ubyte to;
};

enum <byte> NAV2_FEATURE_FLAGS
{
	A = 1 << 0,
	B = 1 << 1,
	C = 1 << 2,
	D = 1 << 7,
};

enum <uint> CHUNK_TYPE
{
	CHUNK_TYPE_NAVIGATION_GRAPH = 0,
	CHUNK_TYPE_NAVMESH_CHUNK = 1,
	CHUNK_TYPE_SEGMENT_GRAPH = 3,
	CHUNK_TYPE_SEGMENT_CHUNK = 4
};

enum <ubyte> CHUNK_TYPE_UINT8
{
	CHUNK_TYPE_NAVIGATION_GRAPH_UINT8 = 0,
	CHUNK_TYPE_NAVMESH_CHUNK_UINT8 = 1,
	CHUNK_TYPE_SEGMENT_GRAPH_UINT8 = 3,
	CHUNK_TYPE_SEGMENT_CHUNK_UINT8 = 4
};

typedef struct
{
	ushort x;
	ushort y;
	ushort z;
} FixedDenominator3 <read = ReadFixedDenominator3String>;
string ReadFixedDenominator3String(FixedDenominator3& fixed)
{
    return Str("%f, %f, %f", (float)fixed.x / Header.Denominator.x, (float)fixed.y / Header.Denominator.x, (float)fixed.z / Header.Denominator.x);
}

typedef struct
{
	FixedDenominator3 Min;
	FixedDenominator3 Max;
} BoundingDesc <read = Str("Min: (%s), Max: (%s)", ReadFixedDenominator3String(Min), ReadFixedDenominator3String(Max))>;

typedef struct
{
    uint Index : 15;
    uint TileId : 16; //Top two bits are special - (+ 0x4000) is for reserved, (+ 0x8000) is for dynamic
    uint Padding : 1 <hidden = true>; Assert(Padding == 0);
} FileUid <optimize = false, read = Str("Index: %u, TileId: %u", Index, TileId)>;

typedef struct
{
    uint Index : 15;
    uint TileId : 16; //Top two bits are special - (+ 0x4000) is for reserved, (+ 0x8000) is for dynamic
    uint Padding : 1 <hidden = true>; Assert(Padding == 0);
} ChunkUid <optimize = false, read = Str("Index: %u, TileId: %u", Index, TileId)>;

// 141af60e3 - need to be super careful here
// 141af9250

struct FileHeader
{
	uint Version; Assert(Version == 201403241 || Version == 201403242);
	uint FileSize;
	uint ChunksOffset;
	uint ChunkCount;
	
	uint SearchSpaceOffset;
	FileUid _FileUid; // 141b16b8a
	uint IslandGraphsOffset;
	uint Unknown_CrossingTileLinkRelated; Assert(Unknown_CrossingTileLinkRelated == 0); // 141af67bf

	Vector3 Origin;

	uint ConnectTileInfosOffset;
	uint Padding0 <hidden = true>; Assert(Padding0 == 0);
	uint ChunkDescsOffset;
	uint ChunkDescsDataSize;
	
	uint Padding1 <hidden = true>; Assert(Padding1 == 0);
	uint Padding2 <hidden = true>; Assert(Padding2 == 0); 

	FixedDenominator3 Denominator;
	ushort WeightDenominator; // Unknown, often 127 (possibly a divisor for Vector4 values?) - weight denominator

	NAV2_FEATURE_FLAGS FeatureFlags; // 141b16b8a
	ubyte IslandGraphCount;
	byte Pre2014_UnknownIndex; Assert(Pre2014_UnknownIndex == 0); // Patched at runtime to be 0xFF if old file version - 141af52cc
	byte Padding3 <hidden = true>; Assert(Padding3 == 0); 
} Header <bgcolor = COLOR_HEADER>;

FSeek(Header.ChunkDescsOffset);	
struct
{
	uint EntryCount;

	struct 
	{
		struct ChunkDesc
		{
			ChunkUid _ChunkUid;

			uint DataOffset;
			CHUNK_TYPE_UINT8 Type;
			ushort DataSize;
			ubyte Unknown; Assert(Unknown == 0 || Unknown == 1);
		} Descs[EntryCount] <read = EnumToString(Type), optimize = false>;
	} TypedChunkDescs[3] <optimize = false>;
} ChunkDescs <bgcolor = COLOR_CHUNKDESC>;

FSeek(Header.ChunksOffset);
struct NavigationGraphChunkHeader
{
	uint VerticesOffset;

	uint NodesOffset;
	uint EdgesOffset;

	uint Subsection3Offset;

	uint Padding0; Assert(Padding0 == 0);
	uint Padding1; Assert(Padding1 == 0);

	uint AttributesOffset;

	uint Padding2; Assert(Padding2 == 0);

	uint NavmeshIndicesOffset; // Related to vertices - 141b1f44e

	ushort NodeCount;
	ushort EdgeCount;

	uint Padding3; Assert(Padding3 == 0);
	ushort Padding4; Assert(Padding4 == 0);

	ushort AttributeCount; // Maybe segment count?

	FSeek(startof(this) + VerticesOffset);
	FixedDenominator3 Vertices [NodeCount] <bgcolor = COLOR_NAVIGATIONGRAPH_VERTICES>;
	
	FSeek(startof(this) + NodesOffset);
	struct NavigationGraphNodeDesc06
	{
		ushort AttributeIndex; // Maybe segment index?
		ushort SegmentIndex : 12; // 141ae373d
		ushort Unknown : 4;
		byte CountA : 3;
		byte Kind : 3; // NavigationGraphKind
		byte Padding : 2; // Assert(Padding == 0);
		byte CountB;
	} Nodes [NodeCount] <bgcolor = COLOR_NAVIGATIONGRAPH_NODES>;

	// Links - ResolveNavmeshTileLink06
	FSeek(startof(this) + Subsection3Offset); // SegmentIndex
	struct
	{
		{
			local int i;
			local int j;
			for (i = 0; i < NodeCount; i++) 
			{
				FSeek (startof(parentof(this)) + Subsection3Offset + (Nodes[i].SegmentIndex * 2));

				struct NavWorldSubsection3Entry
				{
					for (j = 0; j < Nodes[i].CountA; j++) 
					{
						ushort AdjacentNode;
						ushort EdgeIndex;
					}

					for (j = 0; j < Nodes[i].CountB; j++) 
					{
						short Unknown;
					}
				} Subsection3Entries <bgcolor = COLOR_NAVIGATIONGRAPH_SS3>;
			}
		}
	} Subsection3Entries;

	FSeek(startof(this) + EdgesOffset);
	struct NavigationGraphEdgeDesc06
	{
		ushort Weight <read = Str("%f", (float)this / Header.WeightDenominator)>;
		ushort SegmentIndex : 12;
		ushort Kind : 2; Assert(Kind == 0);
		ushort Unknown : 2; Assert(Unknown == 0);

		byte NodeIndex0;
		byte NodeIndex1;
	} Edges[EdgeCount] <optimize = false, bgcolor = COLOR_NAVIGATIONGRAPH_SS4>;

	FSeek(startof(this) + AttributesOffset);
	ushort Attributes[AttributeCount] <bgcolor = COLOR_NAVIGATIONGRAPH_SS5>; // This is the same as the number of "chunks" in the file

	FSeek(startof(this) + NavmeshIndicesOffset);
	ushort NodeNavmeshIndices[NodeCount] <bgcolor = COLOR_NAVIGATIONGRAPH_SS6>; // GetNodeNavmeshHandle
};

struct NavmeshChunkHeader
{
	uint PositionsOffset;

	uint MeshesOffset;
	uint MeshDataOffset;
	
	ushort uu1;
	ushort uu2;
	ushort uu3;
	ushort uu4;
	ushort uu5;
	ushort uu6;

	ushort MeshCount;
	ushort PositionCount;

	ushort u4;
	ushort u5;

	FSeek(startof(this) + PositionsOffset);
	FixedDenominator3 Positions[PositionCount] <bgcolor = COLOR_NAVMESHCHUNK_SS1>;

	FSeek(startof(this) + MeshesOffset);
    struct
    {
        local uint i = 0;
		for (i = 0; i < MeshCount; i++)
		{
			FSeek(startof(this) + i * 4); // sizeof(NavmeshDesc06) == 4; Could also write this line as startof(parentof(this)) + MeshesOffset + i * sizeof(NavmeshDesc06)
			struct NavmeshDesc06
			{
				uint DataOffset : 18;
				uint NeighborInfoCount : 1;
				uint NodeCount : 1;
				uint SegmentIndex : 12;

				FSeek(startof(parentof(parentof(this))) + parentof(parentof(this)).MeshDataOffset + DataOffset * 2);
				struct NeighborNavmeshInfo06
				{
					ushort NavigationGraphMeshIndex : 14;
					ushort Type : 2;
				} NeighborNavmeshInfo[NeighborInfoCount != 0 ? 4 : 3] <bgcolor = COLOR_NAVMESHCHUNK_SS3>;

				byte NodePositionIndices[NeighborInfoCount != 0 ? 4 : 3] <bgcolor = COLOR_NAVMESHCHUNK_SS3>;

				byte NodeIndices[NodeCount != 0 ? 4 : 3] <bgcolor = COLOR_NAVMESHCHUNK_SS3>;

				ushort DataChunkIds[NeighborInfoCount != 0 ? 4 : 3] <bgcolor = COLOR_NAVMESHCHUNK_SS3>;

				ushort TileIds[NeighborInfoCount != 0 ? 4 : 3] <bgcolor = COLOR_NAVMESHCHUNK_SS3>;
			} MeshDesc <bgcolor = COLOR_NAVMESHCHUNK_SS2>;
		}
    } MeshDescs;
};

struct SegmentGraphChunkHeader
{
	uint VerticesOffset;
	uint NodesOffset;
	uint subsection3Offset;

	uint uu1;
	uint totalSize;     // Total size of the entry in bytes
	ushort NodeCount;
	ushort padding1;
	ushort uu3;
	ushort totalEdges; // Probably?
	uint padding;

	FSeek(startof(this) + VerticesOffset);
	FixedDenominator3 Vertices[NodeCount] <bgcolor = COLOR_SEGMENTGRAPH_VERTICES>;

	FSeek(startof(this) + NodesOffset);
	struct SegmentGraphNodeDesc07
	{
		TWENTYFOURBITUINT subsection3Index;
		ubyte nEdges;
		ushort IslandNodeIndex;
		ushort u4;
		byte u5;
		byte u6;
		byte offGroupEdges;
		byte offMeshEdges;
	} Nodes[NodeCount] <bgcolor = COLOR_SEGMENTGRAPH_NODES>;

	// GetSegmentGraphCrossingTileLinkToNode07
	if (subsection3Offset != totalSize)
	{
		FSeek(startof(this) + subsection3Offset);

		struct NavWorldSegmentGraphSubsection3 {

			local int i = 0;
			local int j = 0;
			local int offset = 0;
			local TWENTYFOURBITUINT n;
			for (i = 0; i < NodeCount; i++) {
				n = Nodes[i].subsection3Index;
				offset = (uint)(n[0]) + (((uint)n[1]) << 8) + (((uint)n[2]) << 16);
				FSeek (startof(parentof(this)) + subsection3Offset + offset*2);
				struct NavWorldSegmentGraphSubsection3Entry {
					if (Nodes[i].nEdges > 0) {
						struct NavWorldSegmentType1Edges {
							ushort weight;
							ushort adjacentNode;
							ubyte adjacentEdgeCount;
							ubyte u1;
						}type1Edges[Nodes[i].nEdges];
					}

					if (Nodes[i].offGroupEdges > 0) {
						struct NavWorldSegmentType2Edges {
							ushort groupId;
							ushort weight;
							ushort adjacentNode;
							ubyte adjacentEdgeCount;
							ubyte u5;
						}type2Edges[Nodes[i].offGroupEdges];
					}

					if (Nodes[i].offMeshEdges > 0) {
						struct NavWorldSegmentType3Edges {
							ushort u1;
							ushort groupId;
							ushort adjacentNode;
							ushort u4;
							ubyte adjacentEdgeCount;
							ubyte u6;
						}type3Edges[Nodes[i].offMeshEdges];
					}

					if (Nodes[i].nEdges > 0) {
						for (j = 0; j < Nodes[i].nEdges; j++) {
							struct NavWorldSegmentType1EdgeAdjacentEdges {
								ubyte adjacentEdges[type1Edges[j].adjacentEdgeCount];
							}type1AdjacentEdges;
						}
					}

					if (Nodes[i].offGroupEdges > 0) {
						for (j = 0; j < Nodes[i].offGroupEdges; j++) {
							struct NavWorldSegmentType2EdgeAdjacentEdges {
								ubyte adjacentEdges[type2Edges[j].adjacentEdgeCount];
							}type2AdjacentEdges;
						}
					}

					if (Nodes[i].offMeshEdges > 0) {
						for (j = 0; j < Nodes[i].offMeshEdges; j++) {
							struct NavWorldSegmentType3EdgeAdjacentEdges {
								ubyte adjacentEdges[type3Edges[j].adjacentEdgeCount];
							}type3AdjacentEdges;
						}
					}
				} entries;
			}
		}subsection3<bgcolor = COLOR_SEGMENTGRAPH_SS3>;
	}
};

struct SegmentChunkHeader
{
	uint BoundsOffset;
	uint SegmentsOffset;
	uint SegmentGraphOffset;
	uint SegmentCount;

	FSeek(startof(this) + BoundsOffset);
	BoundingDesc Bounds[SegmentCount] <bgcolor = COLOR_SEGMENTCHUNK_BOUNDS>;

	FSeek(startof(this) + SegmentsOffset);
	struct SegmentDesc06
	{
		short BasePositionIndex;
		short BaseNavigationGraphMeshIndex;
		short BaseNavigationGraphNodeIndex;
		short BaseNavigationGraphEdgeIndex;
		byte PositionCount;
		byte MeshCount;
		byte EdgeCount;
		byte NodeCount;
	} Segments[SegmentCount] <bgcolor = COLOR_SEGMENTCHUNK_SEGMENTS>;
};

struct
{
	CHUNK_TYPE Type; Assert(Type < 5); 

	uint NextChunkOffset;
	uint DataOffset;
	
	ChunkUid _ChunkUid;
	 
	switch(Type)
	{
		case CHUNK_TYPE_NAVIGATION_GRAPH:
			FSeek(startof(this) + DataOffset);
			NavigationGraphChunkHeader Chunk <bgcolor = COLOR_NAVIGATIONGRAPH>;
			break;
		case CHUNK_TYPE_NAVMESH_CHUNK:
			FSeek(startof(this) + DataOffset);
			NavmeshChunkHeader Chunk <bgcolor = COLOR_NAVMESHCHUNK>;
			break;
		case CHUNK_TYPE_SEGMENT_GRAPH:
			FSeek(startof(this) + DataOffset);
			SegmentGraphChunkHeader Chunk <bgcolor = COLOR_SEGMENTGRAPH>;
			break;
		case CHUNK_TYPE_SEGMENT_CHUNK:
			FSeek(startof(this) + DataOffset);
			SegmentChunkHeader Chunk <bgcolor = COLOR_SEGMENTCHUNK>;
			break;
	};

	FSeek(startof(this) + NextChunkOffset);
} Chunks [Header.ChunkCount] <read = Str("%s, uid: {tileId: %u, chunkId: %u}", EnumToString(Type), _ChunkUid.TileId, _ChunkUid.Index), optimize = false, bgcolor = 0x5B1ED8>;

if (Header.IslandGraphsOffset)
{
	struct 
	{
		FSeek(Header.IslandGraphsOffset);

		local uint i = 0;
		for (i = 0; i < Header.IslandGraphCount; i++)
		{
			struct IslandGraphHeader
			{
				ushort NextGraphOffset;
				ushort subsection1RelativeOffset;
				ushort subEntryCount;
				ushort subsection2RelativeOffset;
				ushort LowGraphNodeHandlesOffset;
				ushort subsection4RelativeOffset;
				ushort subsection5RelativeOffset;
				ushort subsection6RelativeOffset;

				FSeek(startof(this) + subsection1RelativeOffset);
				struct Section2Subsection1
				{
					FixedDenominator3 position;
					ushort Attributes;
					ushort subsection2Offset;
					ushort countB;
					byte countA;
					byte Padding0;
				} subsection1Entries[subEntryCount];

				FSeek(startof(this) + subsection2RelativeOffset);

				local int i = 0;
				local int shorts;
				local int ints;
				struct Section2Subsection2 {
					for (i = 0; i < subEntryCount; i++) {
						struct Section2Subsection2Entry {
							if (subsection1Entries[i].countA > 0) {
								struct AEntries {
									ushort weight; // Possibly ?
									ushort adjacentNodeIndex;
								} aEntries[subsection1Entries[i].countA];
							}

							if (subsection1Entries[i].countB > 0) {
								struct BEntries {
									ushort u3;
								} bEntries[subsection1Entries[i].countB];
							}
						} entries;
					}
				} subsection2Entries;

				FSeek(startof(this) + LowGraphNodeHandlesOffset);
				struct IslandGraphLowGraphNodeHandle
				{
					FileUid _FileUid;
					ushort u5;
					ushort u7;
				} LowGraphNodeHandles[subEntryCount] <optimize = false>;

				FSeek(startof(this) + subsection4RelativeOffset);
				struct Section2Subsection4
				{
					// Some kind of count or index. Not unique values.
					ushort n1;
				} subsection4Entries[subEntryCount];

				Assert (subsection6RelativeOffset - subsection5RelativeOffset == 24);

				struct Section2Subsection5
				{
					ubyte u1[24];
				} subsection5Entries;

				// TODO: Subsection 6?

				if (NextGraphOffset != 0)
					FSeek(startof(this) + NextGraphOffset);
			} IslandGraph <bgcolor = COLOR_ISLANDGRAPH>;
		}
	} IslandGraphs;
}

if (Header.SearchSpaceOffset != 0)
{
	FSeek(Header.SearchSpaceOffset);
	struct SearchSpace
	{
		local long selfOffset = startof(this);

		Vector3 Position; 
		ushort RangeY;
		ushort Padding0 <hidden = true>; Assert(Padding0 == 0); // Assumed to be padding

		uint BlockCountX;
		uint BlockCountY;
		uint BlockCountZ;
		uint BlockSizeXZ;

		uint BlockSizeY;
		uint BucketDescsOffset; Assert(BucketDescsOffset == 48);

		uint BucketEntriesOffset;
		uint ConnectTileInfosOffset;

		FSeek(startof(this) + BucketDescsOffset);
		struct SearchBucketDesc
		{
			uint StartOffset;
			ushort Count;
			ubyte u2_MinY; // fox::nav::SearchSpace::GetBucketActualRangeY
			ubyte u3_MaxY; // ""
		} BucketDescs[BlockCountX * BlockCountY * BlockCountZ] < bgcolor = COLOR_SEARCHSPACE_BUCKETDESC>;

		Assert(FTell() == startof(this) + BucketEntriesOffset);

		struct
		{
			local int i;
			local int j;
			for (i = 0; i < BlockCountX * BlockCountY * BlockCountZ; i++) {
				FSeek(startof(BucketDescs[i]) + BucketDescs[i].StartOffset);

				for (j = 0; j < BucketDescs[i].Count; j++) {
					struct SearchBucketEntry
					{
						FileUid Uid; // Is this a full Uid?
						uint IndexCount;
						ushort SegmentIndices[IndexCount]; // SegmentChunks apparently
					} BucketEntry;
				}
			}
		} BucketEntries <bgcolor = COLOR_SEARCHSPACE_BUCKET>;

        FAlign(16);
		Assert(FTell() == selfOffset + ConnectTileInfosOffset);
	} _SearchSpace <bgcolor = COLOR_SEARCHSPACE>;
}

if (Header.ConnectTileInfosOffset != 0)
{
	FSeek(Header.ConnectTileInfosOffset);

	// See fox::nav::service::WorldService::ResolveConnectTileInfosWithName
	struct ConnectTileInfosHeader
	{
		local long infosOffset = startof(this);
		
		ushort GroupsOffset;
		ushort InfosOffset;
		ushort NodesOffset;
		ushort GroupCount;

		struct ConnectTileInfoNodeDesc
		{
			ushort A;
			ushort B;
		};

		struct ConnectTileInfoDesc
		{
			ushort DataChunkId;
			ushort Count : 5 <hidden = true>;
			ushort StartOffset : 11 <hidden = true>;

			FSeek(infosOffset + (2 * NodesOffset) + (4 * StartOffset)); // 4 == sizeof(this)
			for (k = 0; k < Count; k++)
			{
				ConnectTileInfoNodeDesc Node;
			}
		};

		struct ConnectTileInfoGroupDesc
		{
			StrCode32 Name;
			ushort Count : 5 <hidden = true>;
			ushort StartOffset : 11 <hidden = true>;

			FSeek(infosOffset + (2 * InfosOffset) + (4 * StartOffset)); // 4 == sizeof(this)
			for (j = 0; j < Count; j++)
			{
				ConnectTileInfoDesc Info;
			}
		};

		FSeek(infosOffset + 2 * GroupsOffset);
		struct
		{
			local int i;
			local int j;
			local int k;
			for (i = 0; i < GroupCount; i++)
			{
				ConnectTileInfoGroupDesc Group;
			}
		} Groups;
	} _ConnectTileInfosContainer;
}