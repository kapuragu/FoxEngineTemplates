LittleEndian();

#include "common/common.bt"

#define COLOR_HEADER 0xBED655
#define COLOR_CHUNKDESC 0xD9FCAC

#define COLOR_NAVIGATIONGRAPH 0x4F54F0
#define COLOR_NAVIGATIONGRAPH_POSITIONS 0x5F63F1
#define COLOR_NAVIGATIONGRAPH_NODES 0x6F73F2
#define COLOR_NAVIGATIONGRAPH_INSIDELINKS 0x7F82F4
#define COLOR_NAVIGATIONGRAPH_LINKS 0x878AF5
#define COLOR_NAVIGATIONGRAPH_EDGES 0x8F92F5
#define COLOR_NAVIGATIONGRAPH_ATTRIBUTES 0x9FA1F6
#define COLOR_NAVIGATIONGRAPH_NAVMESHINDICES 0xAFB1F8

#define COLOR_NAVMESHCHUNK 0xEBC05B
#define COLOR_NAVMESHCHUNK_SS1 0xECC569
#define COLOR_NAVMESHCHUNK_MESHES 0xEECB78
#define COLOR_NAVMESHCHUNK_NEIGHBORINFO 0xF0D187

#define COLOR_SEGMENTGRAPH 0x3DC59B
#define COLOR_SEGMENTGRAPH_VERTICES 0x4ECAA4
#define COLOR_SEGMENTGRAPH_NODES 0x60CFAD
#define COLOR_SEGMENTGRAPH_SS3 0x71D4B6

#define COLOR_SEGMENTCHUNK 0xB844B7
#define COLOR_SEGMENTCHUNK_BOUNDS 0xC979A3
#define COLOR_SEGMENTCHUNK_SEGMENTS 0xE3B9AD

#define COLOR_ISLANDGRAPH 0x6083FF

#define COLOR_SEARCHSPACE 0x894E00
#define COLOR_SEARCHSPACE_BUCKETDESC 0xB58536
#define COLOR_SEARCHSPACE_BUCKET 0xE6AA89

enum <ubyte> NAV2_FEATURE_FLAGS
{
	A = 1 << 0,
	B = 1 << 1,
	C = 1 << 2,
	D = 1 << 7,
};

enum <uint> CHUNK_TYPE
{
	CHUNK_TYPE_NAVIGATION_GRAPH = 0,
	CHUNK_TYPE_NAVMESH_CHUNK = 1,
	CHUNK_TYPE_SEGMENT_GRAPH = 3,
	CHUNK_TYPE_SEGMENT_CHUNK = 4
};

enum <ubyte> CHUNK_TYPE_UINT8
{
	CHUNK_TYPE_NAVIGATION_GRAPH_UINT8 = 0,
	CHUNK_TYPE_NAVMESH_CHUNK_UINT8 = 1,
	CHUNK_TYPE_SEGMENT_GRAPH_UINT8 = 3,
	CHUNK_TYPE_SEGMENT_CHUNK_UINT8 = 4
};

// NavigationGraphKind
enum <uint> NAVIGATION_GRAPH_KIND
{
	NAVIGATION_GRAPH_KIND_STATIC = 0,
	NAVIGATION_GRAPH_KIND_DYNAMIC = 1,
};

typedef struct
{
	ushort x;
	ushort y;
	ushort z;
} FixedDenominator3 <read = ReadFixedDenominator3String>;
string ReadFixedDenominator3String(FixedDenominator3& fixed)
{
    return Str("%f, %f, %f", (float)fixed.x / Header.Denominator.x, (float)fixed.y / Header.Denominator.x, (float)fixed.z / Header.Denominator.x);
}

typedef struct
{
	FixedDenominator3 Min;
	FixedDenominator3 Max;
} BoundingDesc <read = Str("Min: (%s), Max: (%s)", ReadFixedDenominator3String(Min), ReadFixedDenominator3String(Max))>;

typedef struct
{
    uint Index : 15;
    uint TileId : 16; //Top two bits are special - (+ 0x4000) is for reserved, (+ 0x8000) is for dynamic
    uint Padding : 1 <hidden = true>; Assert(Padding == 0);
} FileUid <optimize = false, read = Str("Index: %u, TileId: %u", Index, TileId)>;

typedef struct
{
    uint Index : 15;
    uint TileId : 16; //Top two bits are special - (+ 0x4000) is for reserved, (+ 0x8000) is for dynamic
    uint Padding : 1 <hidden = true>; Assert(Padding == 0);
} DataChunkUid <optimize = false, read = Str("Index: %u, TileId: %u", Index, TileId)>;

// 141af60e3 - need to be super careful here
// 141af9250

struct FileHeader
{
	uint Version; Assert(Version == 201403241 || Version == 201403242);
	uint FileSize;
	uint ChunksOffset;
	uint ChunkCount;
	
	uint SearchSpaceOffset;
	FileUid _FileUid; // 141b16b8a
	uint IslandGraphsOffset;
	uint Unknown_CrossingTileLinkRelated; Assert(Unknown_CrossingTileLinkRelated == 0); // 141af67bf

	Vector3 Origin;

	uint ConnectTileInfosOffset;
	uint Padding0 <hidden = true>; Assert(Padding0 == 0);
	uint ChunkDescsOffset;
	uint ChunkDescsDataSize;
	
	uint Padding1 <hidden = true>; Assert(Padding1 == 0);
	uint Padding2 <hidden = true>; Assert(Padding2 == 0); 

	FixedDenominator3 Denominator;
	ushort WeightDenominator; // Unknown, often 127 (possibly a divisor for Vector4 values?) - weight denominator

	NAV2_FEATURE_FLAGS FeatureFlags; // 141b16b8a
	ubyte IslandGraphCount;
	ubyte Pre2014_UnknownIndex; Assert(Pre2014_UnknownIndex == 0); // Patched at runtime to be 0xFF if old file version - 141af52cc
	ubyte Padding3 <hidden = true>; Assert(Padding3 == 0); 
} Header <bgcolor = COLOR_HEADER>;

FSeek(Header.ChunkDescsOffset);	
struct
{
	uint EntryCount;

	struct 
	{
		struct ChunkDesc
		{
			DataChunkUid _DataChunkUid;

			uint DataOffset;
			CHUNK_TYPE Type : 8;
			uint DataSize : 16;
			uint Unknown : 8; Assert(Unknown == 0 || Unknown == 1 || Unknown == 2);
		} Descs[EntryCount] <read = EnumToString(Type), optimize = false>;
	} TypedChunkDescs[3] <optimize = false>;
} ChunkDescs <bgcolor = COLOR_CHUNKDESC>;

FSeek(Header.ChunksOffset);
struct NavigationGraphChunkHeader
{
	uint PositionsOffset;

	uint NodesOffset;
	uint EdgesOffset;

	uint LinkDataOffset;

	uint Padding0 <hidden = true>; Assert(Padding0 == 0);
	uint Padding1 <hidden = true>; Assert(Padding1 == 0);

	uint AttributesOffset;

	uint Padding2 <hidden = true>; Assert(Padding2 == 0);

	uint NavmeshIndicesOffset; // 141b1f44e

	ushort NodeCount;
	ushort EdgeCount;

	uint Padding3 <hidden = true>; Assert(Padding3 == 0);
	ushort Padding4 <hidden = true>; Assert(Padding4 == 0);

	ushort AttributeCount;

	FSeek(startof(this) + PositionsOffset);
	FixedDenominator3 Positions[NodeCount] <bgcolor = COLOR_NAVIGATIONGRAPH_POSITIONS>;
	
	FSeek(startof(this) + NodesOffset);
    struct
    {
        local uint i = 0;
		for (i = 0; i < NodeCount; i++)
		{			
			FSeek(startof(this) + i * 6); // sizeof(NavigationGraphNodeDesc06) == 6; Could also write this line as startof(parentof(this)) + NodesOffset + i * sizeof(NavigationGraphNodeDesc06)
			struct NavigationGraphNodeDesc06
			{
				ushort LinkDataOffset;
				ushort SegmentIndex : 12; // 141ae373d
				ushort LinkDataOffsetUpper : 4; Assert(LinkDataOffsetUpper == 0);
				ubyte InsideLinkCount;
				BitfieldDisablePadding();
				ubyte HasSegmentLink : 1;
				ubyte HasDataChunkLink : 1;
				ubyte HasTileLink : 1;
				NAVIGATION_GRAPH_KIND Kind : 2; Assert(Kind == NAVIGATION_GRAPH_KIND_STATIC);
				ubyte Padding : 3 <hidden = true>; Assert(Padding == 0);
				BitfieldEnablePadding();

				Assert(((HasSegmentLink + HasDataChunkLink + HasTileLink) & (~1)) == 0); // Asserts that exactly one or zero of the links are present
				// Printf("%d, %d, %d, %d\n", InsideLinkCount, HasSegmentLink, HasDataChunkLink, HasTileLink);
				
				FSeek(startof(parentof(parentof(this))) + parentof(parentof(this)).LinkDataOffset + (LinkDataOffsetUpper * 16 + LinkDataOffset * 2));
				struct NavigationGraphInsideLinkDesc
				{
					ushort NodeIndex;
					ushort EdgeIndex;
				} InsideLinks[InsideLinkCount] <bgcolor = COLOR_NAVIGATIONGRAPH_INSIDELINKS>;

				if (HasSegmentLink)
				{
					struct NavigationGraphCrossingSegmentLinkDesc // Custom name
					{
						ushort NodeIndex;
					} CrossingSegmentLinkDesc <bgcolor = COLOR_NAVIGATIONGRAPH_LINKS>;
				}

				if (HasDataChunkLink)
				{
					struct NavigationGraphCrossingDataChunkLinkDesc // Custom name
					{
						ushort DataChunkId;
						ushort NodeIndex;
					} CrossingDataChunkLinkDesc <bgcolor = COLOR_NAVIGATIONGRAPH_LINKS>;;
				}

				if (HasTileLink)
				{
					struct NavigationGraphCrossingTileLinkDesc
					{
						ushort TileId;
						ushort DataChunkId;
						ushort NodeIndex; Assert(NodeIndex == 0xFFFF);
					} CrossingTileLinkDesc <bgcolor = COLOR_NAVIGATIONGRAPH_LINKS>;
				}
			} Node <bgcolor = COLOR_NAVIGATIONGRAPH_NODES>;
		}
	} Nodes;

	FSeek(startof(this) + EdgesOffset);
	struct NavigationGraphEdgeDesc06
	{
		ushort Weight <read = Str("%f", (float)this / Header.WeightDenominator)>;
		BitfieldDisablePadding();
		ushort SegmentIndex : 12;
		NAVIGATION_GRAPH_KIND Kind : 2; Assert(Kind == NAVIGATION_GRAPH_KIND_STATIC);
		ushort Padding : 2 <hidden = true>; Assert(Padding == 0);
		BitfieldEnablePadding();

		ubyte NodeIndex0;
		ubyte NodeIndex1;
	} Edges[EdgeCount] <optimize = false, bgcolor = COLOR_NAVIGATIONGRAPH_EDGES>;

	FSeek(startof(this) + AttributesOffset);
	ushort Attributes[AttributeCount] <bgcolor = COLOR_NAVIGATIONGRAPH_ATTRIBUTES>;

	FSeek(startof(this) + NavmeshIndicesOffset);
	ushort NavmeshIndices[NodeCount] <bgcolor = COLOR_NAVIGATIONGRAPH_NAVMESHINDICES>; // GetNodeNavmeshHandle
};

enum <uint> NAVMESH_NEIGHBOR_TYPE
{
	NAVMESH_NEIGHBOR_TYPE_INSIDE = 0,
	NAVMESH_NEIGHBOR_TYPE_CROSSING_DATACHUNK = 1,
	NAVMESH_NEIGHBOR_TYPE_CROSSING_TILE = 2,
	NAVMESH_NEIGHBOR_TYPE_DYNAMIC = 3,
};

struct NavmeshChunkHeader
{
	uint PositionsOffset;

	uint MeshesOffset;
	uint MeshDataOffset;
	
	uint64 Padding0 <hidden = true>; Assert(Padding0 == 0);
	uint Padding1 <hidden = true>; Assert(Padding1 == 0);

	ushort MeshCount;
	ushort PositionCount;

	uint Padding2 <hidden = true>; Assert(Padding2 == 0);

	FSeek(startof(this) + PositionsOffset);
	FixedDenominator3 Positions[PositionCount] <bgcolor = COLOR_NAVMESHCHUNK_SS1>;

	FSeek(startof(this) + MeshesOffset);
    struct
    {
        local uint i = 0;
		for (i = 0; i < MeshCount; i++)
		{
			FSeek(startof(this) + i * 4); // sizeof(NavmeshDesc06) == 4; Could also write this line as startof(parentof(this)) + MeshesOffset + i * sizeof(NavmeshDesc06)
			struct NavmeshDesc06
			{
				uint DataOffset : 18;
				uint Use4NeighborInfos : 1; // TODO; These have to be dynamic or something; the actual tests are always with triangles
				uint Use4NavigationGraphNodes : 1;
				uint SegmentIndex : 12;

				FSeek(startof(parentof(parentof(this))) + MeshDataOffset + DataOffset * 2);
				struct NeighborNavmeshInfo06
				{
					BitfieldDisablePadding();
					ushort NavmeshIndex : 14;
					NAVMESH_NEIGHBOR_TYPE Type : 2;
					BitfieldEnablePadding();
				} NeighborNavmeshInfo[Use4NeighborInfos ? 4 : 3] <optimize = false, bgcolor = COLOR_NAVMESHCHUNK_NEIGHBORINFO>;

				ubyte NeighborPositionIndices[Use4NeighborInfos ? 4 : 3] <bgcolor = COLOR_NAVMESHCHUNK_NEIGHBORINFO>;

				ubyte NavigationGraphNodeIndices[Use4NavigationGraphNodes ? 4 : 3] <bgcolor = COLOR_NAVMESHCHUNK_NEIGHBORINFO>;

				ushort NeighborDataChunkIds[Use4NeighborInfos ? 4 : 3] <bgcolor = COLOR_NAVMESHCHUNK_NEIGHBORINFO>;

				ushort NeighborTileIds[Use4NeighborInfos ? 4 : 3] <bgcolor = COLOR_NAVMESHCHUNK_NEIGHBORINFO>;
			} MeshDesc <bgcolor = COLOR_NAVMESHCHUNK_MESHES>;
		}
    } MeshDescs;
};

struct SegmentGraphChunkHeader
{
	uint VerticesOffset;
	uint NodesOffset;
	uint subsection3Offset;

	uint uu1;
	uint totalSize;     // Total size of the entry in bytes
	ushort NodeCount;
	ushort padding1;
	ushort uu3;
	ushort totalEdges; // Probably?
	uint padding;

	FSeek(startof(this) + VerticesOffset);
	FixedDenominator3 Vertices[NodeCount] <bgcolor = COLOR_SEGMENTGRAPH_VERTICES>;

	FSeek(startof(this) + NodesOffset);
	struct SegmentGraphNodeDesc07
	{
		uint subsection3Index : 24;
		uint nEdges : 8;
		ushort IslandGraphNodeIndices[3]; // 3 == Header.IslandGraphCount - hardcoded, see 141b144b0
		ubyte offGroupEdges;
		ubyte offMeshEdges;
	} Nodes[NodeCount] <optimize = true, bgcolor = COLOR_SEGMENTGRAPH_NODES>;

	// GetSegmentGraphCrossingTileLinkToNode07
	if (subsection3Offset != totalSize)
	{
		FSeek(startof(this) + subsection3Offset);

		struct NavWorldSegmentGraphSubsection3 {

			local int i = 0;
			local int j = 0;
			local int offset = 0;
			for (i = 0; i < NodeCount; i++) {
				FSeek (startof(parentof(this)) + subsection3Offset + Nodes[i].subsection3Index*2);
				struct NavWorldSegmentGraphSubsection3Entry {
					if (Nodes[i].nEdges > 0) {
						struct NavWorldSegmentType1Edges {
							ushort weight;
							ushort adjacentNode;
							ubyte adjacentEdgeCount;
							ubyte u1;
						}type1Edges[Nodes[i].nEdges];
					}

					if (Nodes[i].offGroupEdges > 0) {
						struct NavWorldSegmentType2Edges {
							ushort groupId;
							ushort weight;
							ushort adjacentNode;
							ubyte adjacentEdgeCount;
							ubyte u5;
						}type2Edges[Nodes[i].offGroupEdges];
					}

					if (Nodes[i].offMeshEdges > 0) {
						struct NavWorldSegmentType3Edges {
							ushort u1;
							ushort groupId;
							ushort adjacentNode;
							ushort u4;
							ubyte adjacentEdgeCount;
							ubyte u6;
						}type3Edges[Nodes[i].offMeshEdges];
					}

					if (Nodes[i].nEdges > 0) {
						for (j = 0; j < Nodes[i].nEdges; j++) {
							struct NavWorldSegmentType1EdgeAdjacentEdges {
								ubyte adjacentEdges[type1Edges[j].adjacentEdgeCount];
							}type1AdjacentEdges;
						}
					}

					if (Nodes[i].offGroupEdges > 0) {
						for (j = 0; j < Nodes[i].offGroupEdges; j++) {
							struct NavWorldSegmentType2EdgeAdjacentEdges {
								ubyte adjacentEdges[type2Edges[j].adjacentEdgeCount];
							}type2AdjacentEdges;
						}
					}

					if (Nodes[i].offMeshEdges > 0) {
						for (j = 0; j < Nodes[i].offMeshEdges; j++) {
							struct NavWorldSegmentType3EdgeAdjacentEdges {
								ubyte adjacentEdges[type3Edges[j].adjacentEdgeCount];
							}type3AdjacentEdges;
						}
					}
				} entries;
			}
		}subsection3<bgcolor = COLOR_SEGMENTGRAPH_SS3>;
	}
};

struct SegmentChunkHeader
{
	uint BoundsOffset;
	uint SegmentsOffset;
	uint SegmentGraphOffset;
	uint SegmentCount;

	FSeek(startof(this) + BoundsOffset);
	BoundingDesc Bounds[SegmentCount] <bgcolor = COLOR_SEGMENTCHUNK_BOUNDS>;

	FSeek(startof(this) + SegmentsOffset);
	struct SegmentDesc06
	{
		short BasePositionIndex;
		short BaseNavigationGraphMeshIndex;
		short BaseNavigationGraphNodeIndex;
		short BaseNavigationGraphEdgeIndex;
		ubyte PositionCount;
		ubyte NavigationGraphMeshCount;
		ubyte NavigationGraphEdgeCount;
		ubyte NavigationGraphNodeCount;
	} Segments[SegmentCount] <bgcolor = COLOR_SEGMENTCHUNK_SEGMENTS>;
};

struct
{
	CHUNK_TYPE Type; Assert(Type < 5); 

	uint NextChunkOffset;
	uint DataOffset;
	
	DataChunkUid _DataChunkUid;
	 
	switch(Type)
	{
		case CHUNK_TYPE_NAVIGATION_GRAPH:
			FSeek(startof(this) + DataOffset);
			NavigationGraphChunkHeader Chunk <bgcolor = COLOR_NAVIGATIONGRAPH>;
			break;
		case CHUNK_TYPE_NAVMESH_CHUNK:
			FSeek(startof(this) + DataOffset);
			NavmeshChunkHeader Chunk <bgcolor = COLOR_NAVMESHCHUNK>;
			break;
		case CHUNK_TYPE_SEGMENT_GRAPH:
			FSeek(startof(this) + DataOffset);
			SegmentGraphChunkHeader Chunk <bgcolor = COLOR_SEGMENTGRAPH>;
			break;
		case CHUNK_TYPE_SEGMENT_CHUNK:
			FSeek(startof(this) + DataOffset);
			SegmentChunkHeader Chunk <bgcolor = COLOR_SEGMENTCHUNK>;
			break;
	};

	FSeek(startof(this) + NextChunkOffset);
} Chunks [Header.ChunkCount] <read = Str("%s, uid: {tileId: %u, dataChunkId: %u}", EnumToString(Type), _DataChunkUid.TileId, _DataChunkUid.Index), optimize = false, bgcolor = 0x5B1ED8>;

enum <uint> ISLAND_GRAPH_CONNECT_SIDE_INDEX
{
	ISLAND_GRAPH_CONNECT_SIDE_INDEX_0 = 0,
	ISLAND_GRAPH_CONNECT_SIDE_INDEX_1 = 1,
	ISLAND_GRAPH_CONNECT_SIDE_INDEX_2 = 2,
	ISLAND_GRAPH_CONNECT_SIDE_INDEX_3 = 3,
};

if (Header.IslandGraphsOffset)
{
	struct 
	{
		FSeek(Header.IslandGraphsOffset);

		local uint i = 0;
		for (i = 0; i < Header.IslandGraphCount; i++)
		{
			struct IslandGraphHeader
			{
				ushort NextGraphOffset;
				ushort NodesOffset;
				ushort NodeCount;
				ushort subsection2RelativeOffset;
				ushort LowGraphNodeDescsOffset;
				ushort CountsOffset;
				ushort ConnectSideInfosOffset;
				ushort OffsetsOffset;

				FSeek(startof(this) + NodesOffset);
				struct IslandGraphNodeDesc
				{
					FixedDenominator3 position;
					ushort Attributes;
					ushort subsection2Offset;
					ushort CountC;
					ubyte CountB;
					ubyte CountA;
				} Nodes[NodeCount] <optimize = false>;

				FSeek(startof(this) + subsection2RelativeOffset);

				local int i = 0;
				struct Section2Subsection2 {
					for (i = 0; i < NodeCount; i++) {
						struct Section2Subsection2Entry {

							if (Nodes[i].CountA > 0)
							{
								struct AEntries
								{
									DataChunkUid _DataChunkUid; // I think it's a chunk index? Could be file, technically
									ushort Weight  <read = Str("%f", (float)this / Header.WeightDenominator)>;
									ushort NodeIndex;
								} aEntries[Nodes[i].CountA];
							}

							if (Nodes[i].CountB > 0) {
								struct BEntries 
								{
									ushort Weight  <read = Str("%f", (float)this / Header.WeightDenominator)>; // Possibly ?
									ushort NodeIndex;
								} bEntries[Nodes[i].CountB];
							}
							
							if (Nodes[i].CountC > 0) {
								struct CEntries 
								{
									BitfieldDisablePadding();
									ushort ConnectSideInfoUnknownIndex : 14;
									ISLAND_GRAPH_CONNECT_SIDE_INDEX ConnectSideIndex : 2;
									BitfieldEnablePadding();
								} cEntries[Nodes[i].CountC] <optimize = true>;
							}

						} entries;
					}
				} subsection2Entries;

				FSeek(startof(this) + LowGraphNodeDescsOffset);
				struct IslandGraphLowGraphNodeDesc
				{
					DataChunkUid _DataChunkUid;
					ushort SegmentGraphNodeIndex;
					ushort NavigationGraphNodeIndex;
				} LowGraphNodeDescs[NodeCount] <optimize = false>;

				FSeek(startof(this) + CountsOffset);
				ushort Counts[NodeCount];

				// Reversed and named the old-fashioned way first
				FSeek(startof(this) + ConnectSideInfosOffset);
				struct IslandGraphConnectSideInfoDesc
				{
					local long rewindPos = FTell(); // TODO: Either get rid of this or make all loops use rewindPos pattern

					ushort TileId;
					ushort StartIndex;
					ushort Count;

					FSeek(startof(parentof(this)) + parentof(this).OffsetsOffset + StartIndex * sizeof(uint));

					struct IslandGraphUnknown
					{
						ushort Weight <read = Str("%f", (float)this / Header.WeightDenominator)>;
						ushort NodeIndex;
					} Unknown[Count];

					FSeek(rewindPos + 6); // sizeof(IslandGraphConnectSideInfoDesc)
				} ConnectSideInfos[4] <optimize = false>;

				if (NextGraphOffset != 0)
					FSeek(startof(this) + NextGraphOffset);
			} IslandGraph <bgcolor = COLOR_ISLANDGRAPH>;
		}
	} IslandGraphs;
}

if (Header.SearchSpaceOffset != 0)
{
	FSeek(Header.SearchSpaceOffset);
	struct SearchSpace
	{
		local long selfOffset = startof(this);

		Vector3 Position; 
		ushort RangeY;
		ushort Padding0 <hidden = true>; Assert(Padding0 == 0); // Assumed to be padding

		uint BlockCountX;
		uint BlockCountY;
		uint BlockCountZ;
		uint BlockSizeXZ;

		uint BlockSizeY;
		uint BucketDescsOffset; Assert(BucketDescsOffset == 48);

		uint BucketEntriesOffset;
		uint ConnectTileInfosOffset;

		FSeek(startof(this) + BucketDescsOffset);
		struct SearchBucketDesc
		{
			uint StartOffset;
			ushort Count;
			ubyte u2_MinY; // fox::nav::SearchSpace::GetBucketActualRangeY
			ubyte u3_MaxY; // ""
		} BucketDescs[BlockCountX * BlockCountY * BlockCountZ] < bgcolor = COLOR_SEARCHSPACE_BUCKETDESC>;

		Assert(FTell() == startof(this) + BucketEntriesOffset);

		struct
		{
			local int i;
			local int j;
			for (i = 0; i < BlockCountX * BlockCountY * BlockCountZ; i++) {
				FSeek(startof(BucketDescs[i]) + BucketDescs[i].StartOffset);

				for (j = 0; j < BucketDescs[i].Count; j++) {
					struct SearchBucketEntry
					{
						FileUid Uid; // Is this a full Uid?
						uint IndexCount;
						ushort SegmentIndices[IndexCount]; // SegmentChunks apparently
					} BucketEntry;
				}
			}
		} BucketEntries <bgcolor = COLOR_SEARCHSPACE_BUCKET>;

        FAlign(16);
		Assert(FTell() == selfOffset + ConnectTileInfosOffset);
	} _SearchSpace <bgcolor = COLOR_SEARCHSPACE>;
}

if (Header.ConnectTileInfosOffset != 0)
{
	FSeek(Header.ConnectTileInfosOffset);

	// See fox::nav::service::WorldService::ResolveConnectTileInfosWithName
	struct ConnectTileInfosHeader
	{
		local long headerOffset = startof(this);
		
		ushort GroupsOffset;
		ushort InfosOffset;
		ushort NodesOffset;
		ushort GroupCount;

		struct ConnectTileInfoNodeDesc
		{
			ushort A;
			ushort B;
		};

		struct ConnectTileInfoDesc
		{
			ushort DataChunkId;
			ushort Count : 5;
			ushort StartOffset : 11;

			local int k;
			for (k = 0; k < Count; k++)
			{
				FSeek(headerOffset + (2 * NodesOffset) + (4 * StartOffset) + (k * 4)); // 4 == sizeof(ConnectTileInfoNodeDesc)
				ConnectTileInfoNodeDesc Node;
			}
		};

		struct ConnectTileInfoGroupDesc
		{
			StrCode32 Name;
			ushort Count : 5;
			ushort StartOffset : 11;

			local int j;
			for (j = 0; j < Count; j++)
			{
				FSeek(headerOffset + (2 * InfosOffset) + (4 * StartOffset) + (j * 4)); // 4 == sizeof(ConnectTileInfoDesc)
				ConnectTileInfoDesc Info;
			}
		};

		struct
		{
			local int i;
			for (i = 0; i < GroupCount; i++)
			{
				FSeek(headerOffset + (2 * GroupsOffset) + (i * 6)); // 6 == sizeof(ConnectTileInfoGroupDesc)
				ConnectTileInfoGroupDesc Group;
			}
		} Groups;
	} _ConnectTileInfosContainer;
}